---
title: State of GraphQL Gateways in 2023
tags: [graphql, gateway, benchmark, performance, report]
authors: dotan
image: /blog-assets/state-of-graphql-gateways-in-2023/cover.png
thumbnail: /blog-assets/state-of-graphql-gateways-in-2023/thumbnail.png
date: 2023-09-14
description:
  A six-month journey of researching, benchmarking, exploring and comparing GraphQL gateways and the
  Federation spec in 2023.
---

import NextImage from 'next/image'
import { Callout } from '@theguild/components'
import fedV1ConstantVusOverTime from './fed-v1-constant-vus-over-time.svg'
import fedV1ConstantVusOverTimeDelay from './fed-v1-constants-vus-subgraphs-delay.svg'
import fedV1ConstantVusOverTimeDelayResources from './fed-v1-constants-vus-subgraphs-delay-resources.svg'
import fedV1rampingVus from './fed-v1-ramping-vus.svg'
import gatewayImage from './gw.png'

The GraphQL ecosystem is growing rapidly, and solutions to complex problems are more accessible than
ever before.

One of the most common questions about GraphQL is how to extend or enrich it: this can be achieved
by adding custom flows, securing your `/graphql` endpoint, improving performance through caching,
orchestrating upstream calls for distributed GraphQL, or monitoring and tracing it.

Either a specific ad-hoc solution or a gateway designed specifically for GraphQL can solve all of
the following problems.

**In this blog post, we'll cover The Guild's (and other companies) six-month journey of researching,
exploring, and creating a report on the state of GraphQL gateways in 2023. We compared, tested, and
benchmark various open-source solutions, and we'd like to share our process thus far.**

<Callout type="info" emoji="❣️">
  We would like to thank our partners and customers who took part in that journey!
</Callout>

## But First, What's a GraphQL Gateway?

A GraphQL gateway follows a workflow that adds functionality and acts as a proxy between the
consumer and the actual GraphQL server(s) running the GraphQL schema(s). An architecture diagram of
this setup will look like the following:

<Callout type="info" emoji="">
  <NextImage src={gatewayImage} alt="" className="mt-6" />
</Callout>
In the architecture chart above, the GraphQL gateway responsible for exposing your GraphQL server
externally and adding capabilities to it. The GraphQL server, on the other hand, implements the
actual GraphQL schema and runs resolvers, dataloaders, and any other custom code required for
fetching and connecting your data or entities.

Incorporating a GraphQL gateway into your architecture can help to offload some of the common
features and capabilities from your GraphQL server. Here's a (partial) list of things that a GraphQL
gateway can do:

1. **Caching** in GraphQL can be implemented in various ways, but it doesn't need to be tightly
   coupled to your schema implementation. A GraphQL gateway can handle caching for the GraphQL
   server(s) to reduce network traffic to the actual server. This approach also results in a more
   lightweight and easier-to-maintain GraphQL server implementation.
2. **Authentication** and **authorization** can be managed by the GraphQL gateway. If you are using
   JWT or any other standard, you can verify the token, permissions, and scopes at the gateway
   level. Then, you can pass the authentication metadata (such as user ID) to the GraphQL server.
   This way, your GraphQL server does not need to handle authentication and can focus solely on
   implementing your application's business logic.
3. When it comes to GraphQL servers, **security** is also a concern. By placing a GraphQL gateway in
   front of your GraphQL server, you can easily protect your GraphQL API from malicious queries and
   guard against [common attack vectors](https://escape.tech/blog/tag/graphql-vulnerability/).
4. A GraphQL gateway can also help **harden** your API and prevent the leakage of sensitive
   information, error details, or even PII.
5. **Policy** validations are also a popular feature in GraphQL. Things like rate-limiting,
   depth-limit, or complexity limit can all be implemented in your gateway instead of the server.
6. A GraphQL gateway can also address the lack in **modern features like real-time or
   subscriptions** in your GraphQL server. The gateway can expose a real-time network transport,
   such as WebSocket or SSE, to the consumers while sending a regular HTTP request to the upstream
   GraphQL server.
7. **Schema filtering** can also be implemented at the gateway level, allowing for different sets of
   features, fields, and types to be exposed on each endpoint.
8. And it can also do easy things, like rendering the latest version of **GraphiQL** for you, with the all the enabled transports configured (WebSocket/SSE/HTTP).

## Benchmarking and Comparing GraphQL Gateways

To understand and compare the GraphQL gateway landscape, we began by collecting information about
existing solutions. This included:

1. Which distributed GraphQL specifications are supported.
2. How the product/library is used (as code or as a product).
3. What features are supported.

For our current benchmarks setup, we made the following decisions to ensure a fair comparison
between GraphQL gateways:

1. We used a distributed GraphQL specification to check the performance of a complex setup that
   requires the gateway to take a significant part of the execution flow. We chose the Federation
   (v1) specification since it is widely used and supported by many gateways.
2. We disabled response caching to ensure a complete request flow is executed.
3. We compared responses to ensure that all gateways respond in the same way.
4. We tracked all available vitals and metrics, such as network traffic, CPU, and RAM.
5. We tested different use cases to simulate real-life scenarios with different flows, such as peak
   times or upstream server delays.
6. We are running all scenarios for every change, and have a complete overview of the results and
   the stats of every gateway.
7. We are running Rust-based servers for the subgraphs implementation, to ensure it’s never becoming
   a bottleneck.

For the benchmark, we picked the following gateways:

1. [**Apollo-Server**](https://www.apollographql.com/docs/apollo-server/): a JS/TS library for
   implementing GraphQL servers or gateways.
2. [**GraphQL-Yoga**](https://the-guild.dev/graphql/yoga-server): a JS/TS library for implementing
   GraphQL servers or gateways.
3. [**Apollo-Router**](https://www.apollographql.com/docs/router/): the Rust-based product for
   running Apollo Federation.
4. [**Wundergraph**](https://wundergraph.com/): a Go-based GraphQL gateway and platform.
5. [**GraphQL-Mesh**](https://the-guild.dev/graphql/mesh): a JS/TS GraphQL gateway, that also
   supports anything-to-GraphQL, also supports any other API protocol (REST, OpenAPI, gRPC, SOAP,
   etc) as subgraphs

In addition to that, we used various runtimes for the JavaScript/TypeScript solutions:
[NodeJS](https://nodejs.org/en) (16, 18 and 20), [Deno](https://deno.com/), and
[Bun](https://bun.sh/).

Also, all scenarios are running within Docker container environment, on a stable runner (a dedicated
GitHub Actions runner, that runs 1 concurrent job, to avoid race conditions or missing resources),
and limitations for memory and CPU.

**This decisions above are subject to change, mainly because we want to introduce more options and
more scenarios.**

The [entire source code is open-source](https://github.com/the-guild-org/gateways-benchmark), and we
encourage developers to help us with the following:

- Share more use-cases and realistic scenarios; either by changing the specification used, gateways
  tested, plugins, execution flow or parameters.
- Improve the code of the actual gateways and help to improve the GraphQL ecosystem.

## The Numbers

### `constant-vus-over-time`

> [You can find here the latest results, report and statistics](https://github.com/the-guild-org/gateways-benchmark/blob/main/federation-v1/scenarios/constant-vus-over-time/README.md#overview-for-constant-vus-over-time)

This is the naive, simplest setup with no additional adjustments; the gateway is running the
Federation v1 specification, with a large query (2 top level fields, and 4~7 nested levels,
different entities across multiple subgraphs, and some fragments spreads).

- **VUs:** 300
- **Time:**: 10 minutes
- **CPU limit:** 2
- **Memory limit:** 4GB

| Gateway              | RPS ⬇️ |        Requests        |         Duration         | Notes |
| :------------------- | :----: | :--------------------: | :----------------------: | :---- |
| apollo-router        |  172   | 103759 total, 0 failed | avg: 929ms, p95: 2496ms  | ✅     |
| wundergraph          |  169   | 101815 total, 0 failed | avg: 894ms, p95: 2486ms  | ✅     |
| mesh-bun             |   97   | 58841 total, 0 failed  | avg: 3036ms, p95: 3201ms | ✅     |
| mesh-supergraph      |   83   | 50399 total, 0 failed  | avg: 3541ms, p95: 4417ms | ✅     |
| mesh                 |   72   | 43957 total, 0 failed  | avg: 4076ms, p95: 5613ms | ✅     |
| apollo-server        |   67   | 40913 total, 0 failed  | avg: 4396ms, p95: 6238ms | ✅     |
| apollo-server-node16 |   67   | 40426 total, 0 failed  | avg: 4450ms, p95: 6277ms | ✅     |
| mercurius            |   46   | 28051 total, 0 failed  | avg: 6419ms, p95: 7076ms | ✅     |

<Callout type="info" emoji="">
  <NextImage src={fedV1ConstantVusOverTime} alt="" className="mt-6 w-full" />
</Callout>

- TODO insights

### `constant-vus-subgraphs-delay`

> [You can find here the latest results, report and statistics](https://github.com/the-guild-org/gateways-benchmark/tree/main/federation-v1/scenarios/constant-vus-subgraphs-delay#overview-for-constant-vus-subgraphs-delay)

Same as **`constant-vus-over-time`** but with a random delay (20~150ms) for all upstream HTTP
calls. This scenario forces the gateway to keep more in-flights requests in-memory, and creates a
more realistic scenario.

- **VUs:** 300
- **Time:**: 10 minutes
- **CPU limit:** 2
- **Memory limit:** 4GB

| Gateway         | RPS ⬇️ |        Requests        |          Duration          | Notes |
| :-------------- | :----: | :--------------------: | :------------------------: | :---- |
| wundergraph     |  194   | 117131 total, 0 failed |  avg: 1301ms, p95: 1998ms  | ✅     |
| apollo-router   |  185   | 111345 total, 0 failed |  avg: 1124ms, p95: 2329ms  | ✅     |
| mesh-bun        |   90   | 54599 total, 0 failed  |  avg: 3280ms, p95: 3785ms  | ✅     |
| mesh-supergraph |   82   | 49553 total, 0 failed  |  avg: 3598ms, p95: 4470ms  | ✅     |
| mesh            |   70   | 42526 total, 0 failed  |  avg: 4205ms, p95: 5366ms  | ✅     |
| apollo-server   |   64   | 38969 total, 0 failed  |  avg: 4619ms, p95: 6051ms  | ✅     |
| mercurius       |   12   |  7811 total, 0 failed  | avg: 23482ms, p95: 24625ms | ✅     |

<Callout type="info" emoji="">
  <NextImage src={fedV1ConstantVusOverTimeDelay} alt="" className="mt-6 w-full" />
</Callout>

TODO insights

### `constant-vus-subgraphs-delay-resources`

> [You can find here the latest results, report and statistics](https://github.com/the-guild-org/gateways-benchmark/blob/main/federation-v1/scenarios/constant-vus-subgraphs-delay-resources/README.md#overview-for-constant-vus-subgraphs-delay-resources)

Same as **`constant-vus-subgraphs-delay-resources`** but with additional resources (CPU and RAM) and more concurrent VUs.  

- **VUs:** 500
- **Time:**: 10 minutes
- **CPU limit:** 4
- **Memory limit:** GB

| Gateway         | RPS ⬇️ |        Requests        |          Duration          | Notes |
| :-------------- | :----: | :--------------------: | :------------------------: | :---- |
| wundergraph     |  189   | 114259 total, 0 failed |  avg: 1820ms, p95: 3360ms  | ✅     |
| apollo-router   |  184   | 111024 total, 0 failed |  avg: 1646ms, p95: 3495ms  | ✅     |
| mesh-supergraph |   89   | 54218 total, 0 failed  |  avg: 5464ms, p95: 6281ms  | ✅     |
| mesh-bun        |   87   | 53282 total, 0 failed  |  avg: 5635ms, p95: 6124ms  | ✅     |
| mesh            |   82   | 49600 total, 0 failed  |  avg: 6005ms, p95: 7299ms  | ✅     |
| apollo-server   |   63   | 38179 total, 0 failed  | avg: 7885ms, p95: 18007ms  | ✅     |
| mercurius       |   12   |  7895 total, 0 failed  | avg: 38666ms, p95: 42028ms | ✅     |

<Callout type="info" emoji="">
  <NextImage src={fedV1ConstantVusOverTimeDelayResources} alt="" className="mt-6 w-full" />
</Callout>

TODO insights

### `ramping-vus`

> [You can find here the latest results, report and statistics](https://github.com/the-guild-org/gateways-benchmark/tree/main/federation-v1/scenarios/ramping-vus#overview-for-fed-v1-ramping-vus)

Same as the previous setup, but this scenario aims to push the gateway to the limit by **running a
gradual increase of VUs**. Some gateways are lagging behind or breaks at such scale (with the limitation of resources), and it's easier to spot the top capacity of requests it can handle while under pressure.

- **VUs:** 50 -> 2000 (ramping)
- **Time:**: 10 minutes
- **CPU limit:** 4
- **Memory limit:** 8GB

The chart below measures the **p95** of the request duration (lower is better).

| Gateway         | duration(p95)⬇️ |  RPS  |         Requests         |                       Durations                        | Notes                                                                          |
| :-------------- | :-------------: | :---: | :----------------------: | :----------------------------------------------------: | :----------------------------------------------------------------------------- |
| wundergraph     |     6259ms      |  166  |  101678 total, 0 failed  |  avg: 2675ms, p95: 6259ms, max: 23124ms, med: 2295ms   | ✅                                                                              |
| apollo-router   |     7120ms      |  173  |  105971 total, 0 failed  |  avg: 2608ms, p95: 7121ms, max: 23465ms, med: 2048ms   | ✅                                                                              |
| mesh-bun        |     21115ms     |  92   |  57577 total, 0 failed   | avg: 11138ms, p95: 21116ms, max: 52679ms, med: 10291ms | ✅                                                                              |
| mesh-supergraph |     21399ms     |  90   |  56299 total, 0 failed   | avg: 11237ms, p95: 21399ms, max: 29131ms, med: 11075ms | ✅                                                                              |
| mesh            |     23605ms     |  82   |  51181 total, 0 failed   | avg: 12432ms, p95: 23606ms, max: 31905ms, med: 12327ms | ✅                                                                              |
| apollo-server   |     58994ms     |  63   | 39650 total, 1806 failed | avg: 16289ms, p95: 58994ms, max: 60494ms, med: 4984ms  | ❌ 1806 failed requests, 1806 non-200 responses, 1806 unexpected GraphQL errors |
| mercurius       |     60000ms     |  37   | 24106 total, 2878 failed | avg: 25803ms, p95: 60001ms, max: 60014ms, med: 21404ms | ❌ 2878 failed requests, 2878 non-200 responses, 2878 unexpected GraphQL errors |

<Callout type="info" emoji="">
  <NextImage src={fedV1rampingVus} alt="" className="mt-6 w-full" />
</Callout>

TODO insights

### The Fine Print

Here are some important points to consider regarding the gateways tested in this benchmark:

- **Federation specification compatibility:**
  - Among the list of gateways tested, only `apollo-server`, `apollo-router`, and `graphql-mesh`
    fully support the Federation v1 specification without any adjustments. Other servers, such as
    `wundergraph`, do not have full support (Federation v2 specification is fully supported at the
    moment only by `apollo-router`, `apollo-server` and `graphql-mesh`).
  - We used the Federation Supergraph specification during the server runs, which is an artifact
    produced from a successful composition of subgraphs. Some gateways, like `wundergraph` and
    `mercurius`, do not support this specification, and a list of services was provided with a
    real-time composition based on GraphQL introspection.
  - We chose to use Federation v1 and not Federation v2 for this test because it is widely adopted
    and more supported by available gateways.
- **NodeJS runtimes:**
  - For NodeJS, we used version 18 (LTS) of the engine.
  - In some of the scenarios mentioned above, we used Bun (recently released v1).
- **Fair comparison:**
  - All gateways were running the same GraphQL schema, and the same GraphQL query was executed.
  - All gateways were running as Docker containers, using the latest available version (and were
    kept updated using Renovate).
  - Resources were limited to 1 CPU and 1GB RAM for all gateways in all scenarios.
- **Subgraphs metrics:**
  - In all the scenarios mentioned, all subgraphs consumed approximately 3% of the CPU and 10MB of
    memory. We measured this to ensure that the subgraphs were not becoming the bottleneck and
    affecting the results.

### 

### Keeping This Report Updated

We welcome contributions from the community. If you notice any incorrect configuration, setup, or
any other issue that affects the results or the comparison, please
[reach out to us and report a GitHub issue](https://github.com/the-guild-org/gateways-benchmark/issues/new).
This will help us keep this benchmark up to date and ensure a fair comparison.

We also encourage companies and developers to improve their stack. We would love to update this blog
post when significant changes in results occur (the results in the repository are always up to
date!).

### A Note on Conductor

The Guild is building [Conductor](https://the-guild.dev/graphql/gateway), a powerful GraphQL gateway
aiming to solve the following:

- **GraphQL-first**: Conductor is built from the ground up to be a GraphQL gateway. It is not a
  generic proxy or a reverse proxy, but a gateway that understands GraphQL and can handle it in a
  more efficient way.
- **Multiple specifications**: Conductor will support popular specifications like Apollo Federation,
  but also other specifications like Fusion.
- **Performance**: Conductor is built with performance in mind. It is written in Rust, and it is
  designed to be fast and efficient.
- **Extensibility**: Conductor is built to be extensible. It will support plugins and custom
  extensions to add functionality and features.
- **Security**: Conductor will support various security features out of the box, such as
  rate-limiting, depth-limit, complexity-limit, and more.
- **Monitoring**: Conductor will support monitoring and tracing out of the box. It will also support
  various metrics and vitals to help you understand your GraphQL gateway better.
- **Open-Source**: All tools built by The Guild are MIT open-source, you can use it for free and
  contribute to it.
- **Support**: The Guild is a company that provides support and consulting for GraphQL, we work with
  many companies and learn from their use-cases. We are here to help you with your GraphQL journey.

We are currently working on Conductor, and we are planning to release it in the coming months. If
you are interested in learning more about Conductor, please
[reach out to us](https://the-guild.dev/graphql/gateway) and let us know.
