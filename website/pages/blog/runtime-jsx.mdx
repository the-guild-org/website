---
title: Implementing a runtime version of JSX
authors: eytan
tags: [react]
date: 2018-11-12
description: Learning how to think like a JSX parser and building an AST
image: /medium/fadbe31be89eb8b0be9fc5f035c9617d.png
---

## Learning How to Think like a JSX Parser and Building an AST

JSX is one of the most commonly used syntax extensions out there. Originally JSX was parsed via a
[Facebook fork of Esprima](https://github.com/facebookarchive/esprima) â€” a JavaScript syntax parser
developed by jQuery. As it gained momentum, [Acorn](https://github.com/acornjs/acorn) took things to
their hands and decided to make their own version of the parser which ended up being 1.5â€“2x faster
than Esprima-fb, and is now being used by officially Babel.

It definitely went through an evolution, but regardless of its phase, all parsers had a similar
output â€” which is an AST. Once we have an AST representation of the JSX code, interpretation is
extremely easy.

Today we're going to understand how a JSX parser thinks by implementing one of our own. Unlike
Babel, rather than compiling, we're going to evaluate the nodes in the AST according to their types,
which means that we will be able to use JSX during runtime.

---

Below is an example of the final product:

```javascript
class Hello extends React.Component {
  render() {
    return jsx`<div>Hello ${this.props.name}</div>`
  }
}

ReactDOM.render(jsx`<${Hello} name="World" />`, document.getElementById('container'))
```

Before we go ahead and rush to implementing the parser let's understand what we're aiming for. JSX
simply takes an HTML-like syntax and transforms it into nested `React.createElement()` calls. What
makes JSX unique is that we can use string interpolation within our HTML templates, so we can
provide it with data which doesn't necessarily has to be serialized, things like functions, arrays,
or objects.

So given the following code:

```jsx
const el = props => (
  <div onClick={props.onClick}>
    <Icon src={props.icon} />
    <span>{props.text}</span>
  </div>
)
```

We should get the following output once compiling it with Babel:

```javascript
const el = props =>
  React.createElement(
    'div',
    { onClick: props.onClick },
    React.createElement(Icon, { src: props.icon }),
    React.createElement('span', null, props.text)
  )
```

Just a quick reminder â€” the compiled result should be used internally by `ReactDOM` to differentiate
changes in the virtual DOM and then render them. This is something which is React specific and has
nothing to do with JSX, so at this point we have achieved our goal.

Essentially there are 3 things we should figure out when parsing a JSX code:

- The name / component of the React element.
- The props of the React element.
- The children of the React element, for each this process should repeat itself recursively.

As I mentioned earlier, it would be best if we could break down the code into nodes first and
represent it as an AST. Looking at the input of the example above, we can roughly visualize how we
would pluck the nodes from the code:

![](/medium/fadbe31be89eb8b0be9fc5f035c9617d.png 'Analyzing the JSX code.')

And to put things simple, here's a schematic representation of the analysis above:

![](/medium/7c7f8978be94efed4206593bbf067568.png 'A schematic representation of the analysis.')

Accordingly, we're going to have 3 types of nodes:

- Element node.
- Props node.
- Value node.

Let's decide that each node has a base schema with the following properties:

- node.type â€” which will represent the type name of the node, e.g. `element`, `props` and `value`.
  Based on the node type we can also determine that additional properties that the node's going to
  carry. In our parser, each node type should have the following additional properties:

![](/medium/55cc9640bbaec3a7b9a5948d71adfd3a.png 'Node type schemas.')

- node.length â€”which represents the length of the sub-string in the code that the node occupies.
  This will help us trim the code string as we go with the parsing process so we can always focus on
  relevant parts of the string for the current node:

![](/medium/7ba5847a0000df3ef06a6913a79346f2.png 'Any time we parse a small part of the string, we
slice the part we've just parsed.')

In the function that we're going to build we'll be taking advantage of ES6's tagged templates.
Tagged templates are string literals which can be processed by a custom handler according to our
needs (see
[MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates)).

So essentially the signature of our function should look like this:

```javascript
const jsx = (splits, ...values) => {
  // ...
}
```

Since we're gonna heavily rely on regular expression, it will be much easier to deal with a
consistent string, so we can unleash the regexp full potential. For now let's focus on the string
part without the literal, and parse regular HTML string. Once we have that logic, we can implement
string interpolation handling on top of it.

## Starting with the Core â€” an HTML Parser

As I already mentioned, our AST will be consisted of 3 node types, which means that we will have to
create an ENUM that will contain the values `element`, `props` and `value`. This way the node types
won't be hardcoded and patching the code can be very easy:

```diff
@@ -0,0 +1,5 @@
+â”Š â”Š1â”Šconst types = {
+â”Š â”Š2â”Š  element: 'element',
+â”Š â”Š3â”Š  value: 'value',
+â”Š â”Š4â”Š  props: 'props',
+â”Š â”Š5â”Š}ðŸš«â†µ
```

Since we had 3 node types, it means that for each of them we should have a dedicated parsing
function:

```diff
@@ -2,4 +2,40 @@
 â”Š 2â”Š 2â”Š  element: 'element',
 â”Š 3â”Š 3â”Š  value: 'value',
 â”Š 4â”Š 4â”Š  props: 'props',
-â”Š 5â”Š  â”Š}ðŸš«â†µ
+â”Š  â”Š 5â”Š}
+â”Š  â”Š 6â”Š
+â”Š  â”Š 7â”Šconst parseElement = (str) => {
+â”Š  â”Š 8â”Š  let match
+â”Š  â”Š 9â”Š  let length
+â”Š  â”Š10â”Š
+â”Š  â”Š11â”Š  const node = {
+â”Š  â”Š12â”Š    type: types.element,
+â”Š  â”Š13â”Š    props: parseProps(''),
+â”Š  â”Š14â”Š    children: [],
+â”Š  â”Š15â”Š    length: 0,
+â”Š  â”Š16â”Š    name: '',
+â”Š  â”Š17â”Š  }
+â”Š  â”Š18â”Š
+â”Š  â”Š19â”Š  return node
+â”Š  â”Š20â”Š}
+â”Š  â”Š21â”Š
+â”Š  â”Š22â”Šconst parseProps = (str) => {
+â”Š  â”Š23â”Š  let match
+â”Š  â”Š24â”Š  let length
+â”Š  â”Š25â”Š
+â”Š  â”Š26â”Š  const node = {
+â”Š  â”Š27â”Š    type: types.props,
+â”Š  â”Š28â”Š    length: 0,
+â”Š  â”Š29â”Š    props: {},
+â”Š  â”Š30â”Š  }
+â”Š  â”Š31â”Š
+â”Š  â”Š32â”Š  return node
+â”Š  â”Š33â”Š}
+â”Š  â”Š34â”Š
+â”Š  â”Š35â”Šconst parseValue = (str) => {
+â”Š  â”Š36â”Š  return {
+â”Š  â”Š37â”Š    type: types.value,
+â”Š  â”Š38â”Š    length: str.length,
+â”Š  â”Š39â”Š    value: str.trim(),
+â”Š  â”Š40â”Š  }
+â”Š  â”Š41â”Š}
```

Each function creates the basic node type and returns it. Note that at the beginning of the scope of
each function I've defined a couple of variables:

- `let match` - which will be used to store regular expression matches on the fly.
- `let length` - which will be used to store the length of the match, so we can trim the JSX code
  string right after and accumulate it in `node.length`.

For now the `parseValue()` function is pretty straight forward and just returns a node which wraps
the given string.

We will begin with the implementation of the element node, and we will branch out to other nodes as
we go. First we will try to figure out the name of the element. If an element tag opener was not
found, we will assume that the current part of the code is a value:

```diff
@@ -16,6 +16,19 @@
 â”Š16â”Š16â”Š    name: '',
 â”Š17â”Š17â”Š  }
 â”Š18â”Š18â”Š
+â”Š  â”Š19â”Š  match = str.match(/<(\w+)/)
+â”Š  â”Š20â”Š
+â”Š  â”Š21â”Š  if (!match) {
+â”Š  â”Š22â”Š    str = str.split('<')[0]
+â”Š  â”Š23â”Š
+â”Š  â”Š24â”Š    return parseValue(str)
+â”Š  â”Š25â”Š  }
+â”Š  â”Š26â”Š
+â”Š  â”Š27â”Š  node.name = match[1]
+â”Š  â”Š28â”Š  length = match.index + match[0].length
+â”Š  â”Š29â”Š  str = str.slice(length)
+â”Š  â”Š30â”Š  node.length += length
+â”Š  â”Š31â”Š
 â”Š19â”Š32â”Š  return node
 â”Š20â”Š33â”Š}
```

Up next, we need to parse the props. To make things more efficient, we will need to first find the
tag closer, so we can provide the `parseProps()` method the relevant part of the string:

```diff
@@ -29,6 +29,15 @@
 â”Š29â”Š29â”Š  str = str.slice(length)
 â”Š30â”Š30â”Š  node.length += length
 â”Š31â”Š31â”Š
+â”Š  â”Š32â”Š  match = str.match(/>/)
+â”Š  â”Š33â”Š
+â”Š  â”Š34â”Š  if (!match) return node
+â”Š  â”Š35â”Š
+â”Š  â”Š36â”Š  node.props = parseProps(str.slice(0, match.index), values)
+â”Š  â”Š37â”Š  length = node.props.length
+â”Š  â”Š38â”Š  str = str.slice(length)
+â”Š  â”Š39â”Š  node.length += length
+â”Š  â”Š40â”Š
 â”Š32â”Š41â”Š  return node
 â”Š33â”Š42â”Š}
```

Now that we've plucked the right substring, we can go ahead and implement the `parseProps()`
function logic:

```diff
@@ -51,6 +51,27 @@
 â”Š51â”Š51â”Š    props: {},
 â”Š52â”Š52â”Š  }
 â”Š53â”Š53â”Š
+â”Š  â”Š54â”Š  const matchNextProp = () => {
+â”Š  â”Š55â”Š    match =
+â”Š  â”Š56â”Š      str.match(/ *\w+="(?:.*[^\\]")?/) ||
+â”Š  â”Š57â”Š      str.match(/ *\w+/)
+â”Š  â”Š58â”Š  }
+â”Š  â”Š59â”Š
+â”Š  â”Š60â”Š  matchNextProp()
+â”Š  â”Š61â”Š
+â”Š  â”Š62â”Š  while (match) {
+â”Š  â”Š63â”Š    const propStr = match[0]
+â”Š  â”Š64â”Š    let [key, ...value] = propStr.split('=')
+â”Š  â”Š65â”Š    node.length += propStr.length
+â”Š  â”Š66â”Š    key = key.trim()
+â”Š  â”Š67â”Š    value = value.join('=')
+â”Š  â”Š68â”Š    value = value ? value.slice(1, -1) : true
+â”Š  â”Š69â”Š    node.props[key] = value
+â”Š  â”Š70â”Š    str = str.slice(0, match.index) + str.slice(match.index + propStr.length)
+â”Š  â”Š71â”Š
+â”Š  â”Š72â”Š    matchNextProp()
+â”Š  â”Š73â”Š  }
+â”Š  â”Š74â”Š
 â”Š54â”Š75â”Š  return node
 â”Š55â”Š76â”Š}
```

The logic is pretty straight forward â€” we iterate through the string, and each time we try match the
next key->value pair. Once a pair wasn't found, we return the node with the accumulated props. Note
that providing only an attribute with no value is also a valid syntax which will set its value to
`true` by default, thus the `/ *\w+/` regexp. Let's proceed where we left of with the element
parsing implementation.

We need to figure out whether the current element is self-closing or not. If it is, we will return
the node, and otherwise we will continue to parsing its children:

```diff
@@ -38,6 +38,22 @@
 â”Š38â”Š38â”Š  str = str.slice(length)
 â”Š39â”Š39â”Š  node.length += length
 â”Š40â”Š40â”Š
+â”Š  â”Š41â”Š  match = str.match(/^ *\/ *>/)
+â”Š  â”Š42â”Š
+â”Š  â”Š43â”Š  if (match) {
+â”Š  â”Š44â”Š    node.length += match.index + match[0].length
+â”Š  â”Š45â”Š
+â”Š  â”Š46â”Š    return node
+â”Š  â”Š47â”Š  }
+â”Š  â”Š48â”Š
+â”Š  â”Š49â”Š  match = str.match(/>/)
+â”Š  â”Š50â”Š
+â”Š  â”Š51â”Š  if (!match) return node
+â”Š  â”Š52â”Š
+â”Š  â”Š53â”Š  length = match.index + 1
+â”Š  â”Š54â”Š  str = str.slice(length)
+â”Š  â”Š55â”Š  node.length += length
+â”Š  â”Š56â”Š
 â”Š41â”Š57â”Š  return node
 â”Š42â”Š58â”Š}
```

Accordingly, we're going to implement the children parsing logic:

```diff
@@ -54,6 +54,16 @@
 â”Š54â”Š54â”Š  str = str.slice(length)
 â”Š55â”Š55â”Š  node.length += length
 â”Š56â”Š56â”Š
+â”Š  â”Š57â”Š  let child = parseElement(str)
+â”Š  â”Š58â”Š
+â”Š  â”Š59â”Š  while (child.type === types.element || child.value) {
+â”Š  â”Š60â”Š    length = child.length
+â”Š  â”Š61â”Š    str = str.slice(length)
+â”Š  â”Š62â”Š    node.length += length
+â”Š  â”Š63â”Š    node.children.push(child)
+â”Š  â”Š64â”Š    child = parseElement(str)
+â”Š  â”Š65â”Š  }
+â”Š  â”Š66â”Š
 â”Š57â”Š67â”Š  return node
 â”Š58â”Š68â”Š}
```

Children parsing is recursive. We keep calling the `parseElement()` method for the current substring
until there's no more match. Once we've gone through all the children, we can finish the process by
finding the closing tag:

```diff
@@ -64,6 +64,12 @@
 â”Š64â”Š64â”Š    child = parseElement(str)
 â”Š65â”Š65â”Š  }
 â”Š66â”Š66â”Š
+â”Š  â”Š67â”Š  match = str.match(new RegExp(`</${node.name}>`))
+â”Š  â”Š68â”Š
+â”Š  â”Š69â”Š  if (!match) return node
+â”Š  â”Š70â”Š
+â”Š  â”Š71â”Š  node.length += match.index + match[0].length
+â”Š  â”Š72â”Š
 â”Š67â”Š73â”Š  return node
 â”Š68â”Š74â”Š}
```

The HTML parsing part is finished! Now we can call the `parseElement()` for any given HTML string,
and we should get a JSON output which represents an AST, like the following:

```json
{
  "type": "element",
  "props": {
    "type": "props",
    "length": 20,
    "props": {
      "onclick": "onclick()"
    }
  },
  "children": [
    {
      "type": "element",
      "props": {
        "type": "props",
        "length": 15,
        "props": {
          "src": "icon.svg"
        }
      },
      "children": [],
      "length": 18,
      "name": "img"
    },
    {
      "type": "element",
      "props": {
        "type": "props",
        "length": 0,
        "props": {}
      },
      "children": [
        {
          "type": "value",
          "length": 4,
          "value": "text"
        }
      ],
      "length": 12,
      "name": "span"
    }
  ],
  "length": 74,
  "name": "div"
}
```

## Leveling up â€” String Interpolation

Now we're going to add string interpolation on top of the HTML string parsing logic. Since we still
want to use the power of regexp at its full potential, we're going to assume that the given string
would be a template with placeholders, where each of them should be replaced with a value. That
would be the easiest and most efficient way, rather than accepting an array of string splits.

```text
[
  '<__jsxPlaceholder>Hello __jsxPlaceholder</__jsxPlaceholder>',
  [MyComponent, 'World', MyComponent]
]
```

Accordingly, we will update the parsing functions' signature and their calls, and we will define a
placeholder constant:

```diff
@@ -1,16 +1,18 @@
+â”Š  â”Š 1â”Šconst placeholder = `__jsxPlaceholder${Date.now()}`
+â”Š  â”Š 2â”Š
 â”Š 1â”Š 3â”Šconst types = {
 â”Š 2â”Š 4â”Š  element: 'element',
 â”Š 3â”Š 5â”Š  value: 'value',
 â”Š 4â”Š 6â”Š  props: 'props',
 â”Š 5â”Š 7â”Š}
 â”Š 6â”Š 8â”Š
-â”Š 7â”Š  â”Šconst parseElement = (str) => {
+â”Š  â”Š 9â”Šconst parseElement = (str, values) => {
 â”Š 8â”Š10â”Š  let match
 â”Š 9â”Š11â”Š  let length
 â”Š10â”Š12â”Š
 â”Š11â”Š13â”Š  const node = {
 â”Š12â”Š14â”Š    type: types.element,
-â”Š13â”Š  â”Š    props: parseProps(''),
+â”Š  â”Š15â”Š    props: parseProps('', []),
 â”Š14â”Š16â”Š    children: [],
 â”Š15â”Š17â”Š    length: 0,
 â”Š16â”Š18â”Š    name: '',
@@ -21,7 +23,7 @@
 â”Š21â”Š23â”Š  if (!match) {
 â”Š22â”Š24â”Š    str = str.split('<')[0]
 â”Š23â”Š25â”Š
-â”Š24â”Š  â”Š    return parseValue(str)
+â”Š  â”Š26â”Š    return parseValue(str, values)
 â”Š25â”Š27â”Š  }
 â”Š26â”Š28â”Š
 â”Š27â”Š29â”Š  node.name = match[1]
@@ -54,14 +56,14 @@
 â”Š54â”Š56â”Š  str = str.slice(length)
 â”Š55â”Š57â”Š  node.length += length
 â”Š56â”Š58â”Š
-â”Š57â”Š  â”Š  let child = parseElement(str)
+â”Š  â”Š59â”Š  let child = parseElement(str, values)
 â”Š58â”Š60â”Š
 â”Š59â”Š61â”Š  while (child.type === types.element || child.value) {
 â”Š60â”Š62â”Š    length = child.length
 â”Š61â”Š63â”Š    str = str.slice(length)
 â”Š62â”Š64â”Š    node.length += length
 â”Š63â”Š65â”Š    node.children.push(child)
-â”Š64â”Š  â”Š    child = parseElement(str)
+â”Š  â”Š66â”Š    child = parseElement(str, values)
 â”Š65â”Š67â”Š  }
 â”Š66â”Š68â”Š
 â”Š67â”Š69â”Š  match = str.match(new RegExp(`</${node.name}>`))
@@ -73,7 +75,7 @@
 â”Š73â”Š75â”Š  return node
 â”Š74â”Š76â”Š}
 â”Š75â”Š77â”Š
-â”Š76â”Š  â”Šconst parseProps = (str) => {
+â”Š  â”Š78â”Šconst parseProps = (str, values) => {
 â”Š77â”Š79â”Š  let match
 â”Š78â”Š80â”Š  let length
 â”Š79â”Š81â”Š
@@ -107,7 +109,7 @@
 â”Š107â”Š109â”Š  return node
 â”Š108â”Š110â”Š}
 â”Š109â”Š111â”Š
-â”Š110â”Š   â”Šconst parseValue = (str) => {
+â”Š   â”Š112â”Šconst parseValue = (str, values) => {
 â”Š111â”Š113â”Š  return {
 â”Š112â”Š114â”Š    type: types.value,
 â”Š113â”Š115â”Š    length: str.length,
```

Note how I used the `Date.now()` function to define a postfix for the placeholder. This we can be
sure that the same value won't be given by the user as a string (possible, very unlikely). Now we
will go through each parsing function, and we'll make sure that it knows how to deal with
placeholders correctly. We will start with the `parseElement()` function.

We will add an additional property to the node called: `node.tag`. The tag property is the component
that will be used to create the React element. It can either be a string or a React.Component. If
`node.name` is a placeholder, we will be taking the next value in the given values stack:

```diff
@@ -27,6 +27,7 @@
 â”Š27â”Š27â”Š  }
 â”Š28â”Š28â”Š
 â”Š29â”Š29â”Š  node.name = match[1]
+â”Š  â”Š30â”Š  node.tag = node.name === placeholder ? values.shift() : node.name
 â”Š30â”Š31â”Š  length = match.index + match[0].length
 â”Š31â”Š32â”Š  str = str.slice(length)
 â”Š32â”Š33â”Š  node.length += length
@@ -72,6 +73,12 @@
 â”Š72â”Š73â”Š
 â”Š73â”Š74â”Š  node.length += match.index + match[0].length
 â”Š74â”Š75â”Š
+â”Š  â”Š76â”Š  if (node.name === placeholder) {
+â”Š  â”Š77â”Š    const value = values.shift()
+â”Š  â”Š78â”Š
+â”Š  â”Š79â”Š    if (value !== node.tag) return node
+â”Š  â”Š80â”Š  }
+â”Š  â”Š81â”Š
 â”Š75â”Š82â”Š  return node
 â”Š76â”Š83â”Š}
```

We also made sure that the closing tag matches the opening tag. I've decided to â€œswallowâ€ errors
rather than throwing them for the sake of simplicity, but generally speaking it would make a lot of
sense to implement error throws within the parsing functions.

Up next would be the props node. This is fairly simple, we're only going to add an additional regexp
to the array of matchers, and that regexp will check for placeholders. If a placeholder was
detected, we're going to replace it with the next value in the values stack:

```diff
@@ -95,6 +95,7 @@
 â”Š 95â”Š 95â”Š  const matchNextProp = () => {
 â”Š 96â”Š 96â”Š    match =
 â”Š 97â”Š 97â”Š      str.match(/ *\w+="(?:.*[^\\]")?/) ||
+â”Š   â”Š 98â”Š      str.match(new RegExp(` *\\w+=${placeholder}`)) ||
 â”Š 98â”Š 99â”Š      str.match(/ *\w+/)
 â”Š 99â”Š100â”Š  }
 â”Š100â”Š101â”Š
@@ -106,7 +107,9 @@
 â”Š106â”Š107â”Š    node.length += propStr.length
 â”Š107â”Š108â”Š    key = key.trim()
 â”Š108â”Š109â”Š    value = value.join('=')
-â”Š109â”Š   â”Š    value = value ? value.slice(1, -1) : true
+â”Š   â”Š110â”Š    value =
+â”Š   â”Š111â”Š      value === placeholder ? values.shift() :
+â”Š   â”Š112â”Š      value ? value.slice(1, -1) : true
 â”Š110â”Š113â”Š    node.props[key] = value
 â”Š111â”Š114â”Š    str = str.slice(0, match.index) + str.slice(match.index + propStr.length)
```

Last but not least, would be the value node. This is the most complex to handle out of the 3 nodes,
since it requires us to split the input string and create a dedicated value node out of each split.
So now, instead of returning a single node value, we will return an array of them. Accordingly, we
will also be changing the name of the function from `parseValue()` to `parseValues()`:

```diff
@@ -23,7 +23,7 @@
 â”Š23â”Š23â”Š  if (!match) {
 â”Š24â”Š24â”Š    str = str.split('<')[0]
 â”Š25â”Š25â”Š
-â”Š26â”Š  â”Š    return parseValue(str, values)
+â”Š  â”Š26â”Š    return parseValues(str, values)
 â”Š27â”Š27â”Š  }
 â”Š28â”Š28â”Š
 â”Š29â”Š29â”Š  node.name = match[1]
@@ -57,14 +57,26 @@
 â”Š57â”Š57â”Š  str = str.slice(length)
 â”Š58â”Š58â”Š  node.length += length
 â”Š59â”Š59â”Š
-â”Š60â”Š  â”Š  let child = parseElement(str, values)
+â”Š  â”Š60â”Š  let children = []
 â”Š61â”Š61â”Š
-â”Š62â”Š  â”Š  while (child.type === types.element || child.value) {
-â”Š63â”Š  â”Š    length = child.length
-â”Š64â”Š  â”Š    str = str.slice(length)
-â”Š65â”Š  â”Š    node.length += length
-â”Š66â”Š  â”Š    node.children.push(child)
-â”Š67â”Š  â”Š    child = parseElement(str, values)
+â”Š  â”Š62â”Š  const parseNextChildren = () => {
+â”Š  â”Š63â”Š    children = [].concat(parseElement(str, values))
+â”Š  â”Š64â”Š  }
+â”Š  â”Š65â”Š
+â”Š  â”Š66â”Š  parseNextChildren()
+â”Š  â”Š67â”Š
+â”Š  â”Š68â”Š  while (children.length) {
+â”Š  â”Š69â”Š    children.forEach((child) => {
+â”Š  â”Š70â”Š      length = child.length
+â”Š  â”Š71â”Š      str = str.slice(length)
+â”Š  â”Š72â”Š      node.length += length
+â”Š  â”Š73â”Š
+â”Š  â”Š74â”Š      if (child.type !== types.value || child.value) {
+â”Š  â”Š75â”Š        node.children.push(child)
+â”Š  â”Š76â”Š      }
+â”Š  â”Š77â”Š    })
+â”Š  â”Š78â”Š
+â”Š  â”Š79â”Š    parseNextChildren()
 â”Š68â”Š80â”Š  }
 â”Š69â”Š81â”Š
 â”Š70â”Š82â”Š  match = str.match(new RegExp(`</${node.name}>`))
@@ -119,10 +131,40 @@
 â”Š119â”Š131â”Š  return node
 â”Š120â”Š132â”Š}
 â”Š121â”Š133â”Š
-â”Š122â”Š   â”Šconst parseValue = (str, values) => {
-â”Š123â”Š   â”Š  return {
-â”Š124â”Š   â”Š    type: types.value,
-â”Š125â”Š   â”Š    length: str.length,
-â”Š126â”Š   â”Š    value: str.trim(),
-â”Š127â”Š   â”Š  }
+â”Š   â”Š134â”Šconst parseValues = (str, values) => {
+â”Š   â”Š135â”Š  const nodes = []
+â”Š   â”Š136â”Š
+â”Š   â”Š137â”Š  str.split(placeholder).forEach((split, index, splits) => {
+â”Š   â”Š138â”Š    let value
+â”Š   â”Š139â”Š    let length
+â”Š   â”Š140â”Š
+â”Š   â”Š141â”Š    value = split
+â”Š   â”Š142â”Š    length = split.length
+â”Š   â”Š143â”Š    str = str.slice(length)
+â”Š   â”Š144â”Š
+â”Š   â”Š145â”Š    if (length) {
+â”Š   â”Š146â”Š      nodes.push({
+â”Š   â”Š147â”Š        type: types.value,
+â”Š   â”Š148â”Š        length,
+â”Š   â”Š149â”Š        value,
+â”Š   â”Š150â”Š      })
+â”Š   â”Š151â”Š    }
+â”Š   â”Š152â”Š
+â”Š   â”Š153â”Š    if (index === splits.length - 1) return
+â”Š   â”Š154â”Š
+â”Š   â”Š155â”Š    value = values.pop()
+â”Š   â”Š156â”Š    length = placeholder.length
+â”Š   â”Š157â”Š
+â”Š   â”Š158â”Š    if (typeof value === 'string') {
+â”Š   â”Š159â”Š      value = value.trim()
+â”Š   â”Š160â”Š    }
+â”Š   â”Š161â”Š
+â”Š   â”Š162â”Š    nodes.push({
+â”Š   â”Š163â”Š      type: types.value,
+â”Š   â”Š164â”Š      length,
+â”Š   â”Š165â”Š      value,
+â”Š   â”Š166â”Š    })
+â”Š   â”Š167â”Š  })
+â”Š   â”Š168â”Š
+â”Š   â”Š169â”Š  return nodes
 â”Š128â”Š170â”Š}
```

The reason why I've decided to return an array of nodes and not a singe node which contains an array
of values, just like the props node, is because it matches the signature of `React.createElement()`
perfectly. The values will be passed as children with a spread operator (`...`), and you should see
further this tutorial how this well it fits.

Note that we've also changed the way we accumulate children in the `parseElement()` function. Since
`parseValues()`returns an array now, and not a single node, we flatten it using an empty array
concatenation (`[].concat()`), and we only push the children whose contents are not empty.

## The Grand Finale â€” Execution

At this point we should have a function which can transform a JSX code into an AST, including string
interpolation. The only thing which is left to do now is build a function which will recursively
create React elements out of the nodes in the tree.

The main function of the module should be called with a template tag. If you went through the
previous step, you should know that a consistent string has an advantage over an array of splits of
strings, since we can unleash the full potential of a regexp with ease. Accordingly, we will take
all the given splits and join them with the `placeholder` constant.

```text
['<', '> Hello ', '</', '>'] // '<__jsxPlaceholder>Hello __jsxPlaceholder</__jsxPlaceholder>'
```

Once we join the string we can create React elements recursively:

```diff
@@ -1,3 +1,5 @@
+â”Š â”Š1â”Šimport React from 'react'
+â”Š â”Š2â”Š
 â”Š1â”Š3â”Šconst placeholder = `__jsxPlaceholder${Date.now()}`
 â”Š2â”Š4â”Š
 â”Š3â”Š5â”Šconst types = {
@@ -6,6 +8,24 @@
 â”Š 6â”Š 8â”Š  props: 'props',
 â”Š 7â”Š 9â”Š}
 â”Š 8â”Š10â”Š
+â”Š  â”Š11â”Šexport const jsx = (splits, ...values) => {
+â”Š  â”Š12â”Š  const root = parseElement(splits.join(placeholder), values)
+â”Š  â”Š13â”Š
+â”Š  â”Š14â”Š  return createReactElement(root)
+â”Š  â”Š15â”Š}
+â”Š  â”Š16â”Š
+â”Š  â”Š17â”Šconst createReactElement = (node) => {
+â”Š  â”Š18â”Š  if (node.type === types.value) {
+â”Š  â”Š19â”Š    return node.value
+â”Š  â”Š20â”Š  }
+â”Š  â”Š21â”Š
+â”Š  â”Š22â”Š  return React.createElement(
+â”Š  â”Š23â”Š    node.tag,
+â”Š  â”Š24â”Š    node.props.props,
+â”Š  â”Š25â”Š    ...node.children.map(createReactElement),
+â”Š  â”Š26â”Š  )
+â”Š  â”Š27â”Š}
+â”Š  â”Š28â”Š
 â”Š 9â”Š29â”Šconst parseElement = (str, values) => {
 â”Š10â”Š30â”Š  let match
 â”Š11â”Š31â”Š  let length
@@ -168,3 +188,5 @@
 â”Š168â”Š188â”Š
 â”Š169â”Š189â”Š  return nodes
 â”Š170â”Š190â”Š}
+â”Š   â”Š191â”Š
+â”Š   â”Š192â”Šexport default jsx
```

Note that if a node of value type is being iterated, we will just return the raw string, otherwise
we will try to address its `node.children` property which doesn't exist.

---

Our JSX runtime function is now ready to use!

If you wonder how did I structure this tutorial so nicely with steps and beautiful diffs â€” check out
[tortilla.academy](https://tortilla.academy) by [Uri Goldshtein](https://twitter.com/UriGoldshtein).

Lastly, you can view the source code at the official
[GitHub repository](https://github.com/DAB0mB/jsx-runtime), or you can download a Node.js package
using NPM:

```bash
npm install jsx-runtime
```
