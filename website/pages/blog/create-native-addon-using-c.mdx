---
title: How to create a native add-on using C++
authors: eytan
tags: [cpp]
date: 2017-05-08
description: Node.js Advanced â€” How to create a native add-on using C++
image: /medium/6989c5ee48f37336c330100619adbe13.png
---

In this tutorial we're going to go through the basics on how to write a native add-on to NodeJS
using C++, one of the platform's most powerful capabilities of which most web/JS developers now a
days are not even familiar with.

For somewhat there is a vacuum which got created around C++ in the recent years, people are so
scared from a low-level back-end programming, why should they even deal with memory allocation
dilemmas when there are all these interpretation languages like Python, Ruby, and JavaScript who can
do that for us? Well folks, once you will realize that all these single web-page application
third-party libraries and frameworks are all recycled and repetitive, and you will start doing some
real shit by optimizing some heavy-ass machine algorithms, you will realize that performance is
critic, a title which doesn't really suit NodeJS, with all the love and respect. So why do I even
bother making this tutorial? Because people are unaware of many features in the programming world,
and the beauty of algorithmics. And why am I even approaching NodeJS developers? Because they have
the biggest, most-popular community of all, they have a lot to learn, but they are very open-minded,
and that's the most important thing. You don't have to be a C++ developer not at all, but if I can
at least catch a small part of your attention I will be overwhelmed.

We will create a very small and simple module which calculates the distance between two dots, it can
do it either synchronously or asynchronously. The algorithm for calculating the distance between a
given `pointA` and `pointB` in a 2D
[Cartesian coordinate system](https://en.wikipedia.org/wiki/Cartesian_coordinate_system) looks like
this:

```
âˆš[(pointAX - pointBX)^2 + (pointAY - pointBY)^2]
```

Probably not too complicated, kicks me back to the glamorous days in high-school. If put in
JavaScript it should take around 10 seconds right? Well in a native NodeJS add-on it should be a bit
longer. Of-course when it comes to small logics you shouldn't make too much effort, because it will
consume more power only converting all JS objects into C++ native structures. But imagine you would
like to run a [blob-detection](https://en.wikipedia.org/wiki/Blob_detection) algorithm and you would
like to calculate the [center of mass](https://en.wikipedia.org/wiki/Center_of_mass) of multiple
blobs, in C++ it would be much faster, especially when using
[shaders](https://en.wikipedia.org/wiki/Shader). Anyway that's not the point of this tutorial, the
point is that you will be provided with the necessary tools so next time if you would like to write
some heavy logic, you will know how to do it.

We will start with a brief introduction for Google's
[v8 engine](<https://en.wikipedia.org/wiki/V8_(JavaScript_engine)>) and some practical examples on
how to use it, this will help us to get start, and then we will write our add-on. Let's begin then
shall we?

---

## Introduction to V8

![](/medium/6989c5ee48f37336c330100619adbe13.png)

The v8 JavaScript Engine is an open source JavaScript engine developed by The
[Chromium Project](https://chromium.org) for the
[Google Chrome web browser](https://google.com/chrome). It is intended to be used both in a browser
and as a standalone high-performance engine that can be integrated into independent projects like
[Couchbase](https://couchbase.com), [MongoDB](https://mongodb.com) and
[Node.js](https://nodejs.org). There lots of benchmarks out there but I will not bore you with
diagrams, we all know that this engine has proven itself to be worthy, and it is being used
world-widely and probably for a good reason.

> _â€œAmbition is a dream with a v8 engineâ€ -Elvis Presley._

If you're a JavaScript developer you must be familiar with the event-loop and the scoping system of
v8, so it's a good thing that you understand the concept, but you never got to actually look at its
source code and explicitly use it. A detailed documentation for v8's different API versions is
available [here](https://v8docs.nodesource.com). I assume that you don't bother reading any of my
references that I provide along this tutorial (As a lazy blog-reader myself), I will post here that
first thing you're going to see once you enter v8's documentation web-site:

![](/medium/e2b532f4bd546a9c1bdb1cb2022fbd80.jpg)

Throughout history v8 have changed a lot, and it wore many forms. As a result, add-ons are not
usable across different versions of the platform since each one supports a different API, which will
break our process during run-time. In NodeJS team they came up with a very convenient solution
called [Nan](https://github.com/nodejs/nan). Nan stands for â€œNative Abstractions for NodeJSâ€ and is
basically a header file filled with macro and utility goodness for making add-on development for
NodeJS easier across all versions of v8, without inspecting `NODE_MODULE_VERSION` macro all the
time. In this tutorial I'm going to refer both of them as if they are bundled in a single framework.

Eventually JavaScript is just a rehash of v8, everything you know so far is still valid, but it uses
a different idiom. To prevent some misconceptions, here are some important points regards
JavaScript's equivalents which I think you should follow:

### Scopes and Variables

In v8 a scope is referred as `Isolate` (`v8::Isolate`) and a variable is referred as `Local`
(`v8::Local`). A local is a pointer to an object. All v8 objects are accessed using locals, they are
necessary because of the way the v8 garbage collector works. An isolate can be thought of as a
container for any number of locals. When you've finished with your locals, instead of deleting each
one individually you can simply delete their scope.

**JavaScript**

```javascript
let obj = {
  foo: 'foo',
  bar: 'bar',
  baz: 'baz'
}
```

```javascript
console.log(obj.foo)
console.log(obj.bar)
console.log(obj.baz)
```

**C++**

```cpp
using Nan::New;
using std::cendl;
using std::cout;
using v8::Local;
using v8::Object;
using v8::String;

Local<Object> obj = New<Object>();

obj->Set(New<String>("foo").ToLocalChecked(), New<String>("foo").ToLocalChecked());
obj->Set(New<String>("bar").ToLocalChecked(), New<String>("bar").ToLocalChecked());
obj->Set(New<String>("baz").ToLocalChecked(), New<String>("baz").ToLocalChecked());

cout << obj->Get(New<String>("foo").ToLocalChecked()) << cendl;
cout << obj->Get(New<String>("bar").ToLocalChecked()) << cendl;
cout << obj->Get(New<String>("baz").ToLocalChecked()) << cendl;
```

### Asynchronous Callbacks

Asynchronous logic can be implemented using the `AsyncWorker` (`Nan::AsyncWorker`) and invoked by
`AsyncQueueWorker` (`Nan::AsyncQueueWorker`). Thanks to these two you can have much of the annoying
asynchronous queuing and handling taken care of for you. It can even store arbitrary V8 objects for
you and have them persist while the asynchronous work is in progress.

**JavaScript**

```javascript
setImmediate(() => {
  callback(null, 'result')
})
```

**C++**

```cpp
using Nan::AsyncQueueWorker;
using Nan::AsyncWorker;
using Nan::HandleScope;
using Nan::New;
using Nan::Null;
using std::string;
using v8::Local;
using v8::String;

class ResultWorker : AsyncWorker {
 private:
  string* result

 public:
  ResultWorker(Callback* callback) : AsyncWorker(callback) {}

  ~ResultDistance() {
    delete result;
  }

  // Executed inside the worker-thread.
  // It is not safe to access V8, or V8 data structures
  // here, so everything we need for input and output
  // should go on 'this'.
  void Execute () {
    result = new string("result");
  }

  // Executed when the async work is complete.
  // This function will be run inside the main event loop
  // so it is safe to use V8 again.
  void HandleOKCallback () {
    HandleScope scope;
    Local<Value> argv[] = {
      Null(),
      New<String>(result).ToLocalChecked()
    };
    callback->Call(2, argv);
  }
};

AsyncQueueWorker(new ResultWorker(callback));
```

### Modules Registration and Methods Definition

v8 and Nan provide us with some handy macros (`NODE_MODULE`, `NAN_MODULE_INIT`, `NAN_METHOD` and
`NODE_SET_METHOD`) which will help us register a new NodeJS module and define its methods. This
might be confusing for some, since we can't see the function's signature it would appear as if
variables are just being magically created in the stack, but once the macros are being pre-processed
they will just turn into ordinary functions. In the example below I commented the original signature
so you can have more clew on what's going on.

**JavaScript**

```javascript
exports.fn = (a, b) => a + b
```

**C++**

```cpp
using Nan::To;
using v8::Local;
using v8::Object;

// void Fn(FunctionCallbackInfo<Value>& info)
NAN_METHOD(Fn) {
  double a = To<double>(info[0]).FromJust();
  double b = To<double>(info[1]).FromJust();

  info.GetReturnValue().Set(a + b);
}

// void Init(Local<Object> target)
NAN_MODULE_INIT(Init) {
  NODE_SET_METHOD(target, Fn);
}

// First argument would be the entry file's name
NODE_MODULE(addon, Init);
```

As you can see when dealing with v8 explicitly is a time-consuming process which requires you to do
lots of extra-work. With that said, keep in mind that only a small portion of your code is going to
interact with the engine since the core logic should be written using native C++ and other
third-party libraries. You always need to find the right balance. Always make sure that your add-on
doesn't require too much data to be passed otherwise the conversion process is gonna be hard and
inefficient, and think twice before you choose this approach for the sake of simplicity. Overall the
estimated optimization should be around 150% and up, depends on the task, first check your
JavaScript code snippet, check for unnecessary logic and optimize it, and if you're really sure that
it is fully optimized, and you're still striving for more performance, _only then_ move to C++.

So far I went through the very basics which will help you create this bridge between the two
platforms. The v8 lacks of detailed documentation, tutorials and examples.
[Nan](https://github.com/nodejs/nan) however is a bit more documented IMHO, so when I approach the
API documentation I would start from there, and if I didn't find anything useful I would look at
v8's [latest API docs](https://v8docs.nodesource.com). It's not a hard material to learn but it's
different, so it might be a bit challenging for some, but remember, practice practice practice.

Speaking of practice, let's move on to the next step where we going to implement our first add-on
for distance calculation between two points.

---

## Creating the Add-On

In this step we will base our development process on the TDD methodology, so you will have a chance
to look at the final target API that we desire. We will start by writing a test file:

### [Add Test File](https://github.com/DAB0mB/node-distance-addon/commit/823f652)

**Added `.npmignore`**

```diff
+â”Š â”Š1â”Štest.js
```

**Added `test.js`**

```diff
+â”Š  â”Š 1â”Šconst Distance = require('.');
+â”Š  â”Š 2â”Š
+â”Š  â”Š 3â”Šlet result;
+â”Š  â”Š 4â”Šlet pointA = { x: 0, y: 0 };
+â”Š  â”Š 5â”Šlet pointB = { x: 3, y: 4 };
+â”Š  â”Š 6â”Š
+â”Š  â”Š 7â”Šresult = Distance.calculate.sync(pointA, pointB);
+â”Š  â”Š 8â”Š
+â”Š  â”Š 9â”Šif (result !== 5) throw Error(
+â”Š  â”Š10â”Š  '#Sync: Result expected to equal 5 but instead got ' + result
+â”Š  â”Š11â”Š);
+â”Š  â”Š12â”Š
+â”Š  â”Š13â”Šconsole.log('sync calculation passed');
+â”Š  â”Š14â”Š
+â”Š  â”Š15â”Šresult = Distance.calculate.async(pointA, pointB, (err, result) => {
+â”Š  â”Š16â”Š  if (err) throw err;
+â”Š  â”Š17â”Š
+â”Š  â”Š18â”Š  if (result !== 5) throw Error(
+â”Š  â”Š19â”Š    '#Async: Result expected to equal 5 but instead got ' + result
+â”Š  â”Š20â”Š  );
+â”Š  â”Š21â”Š
+â”Š  â”Š22â”Š  console.log('async calculation passed');
+â”Š  â”Š23â”Š});ğŸš«â†µ
```

And the following NPM script should execute it:

### [Add npm Test Script](https://github.com/DAB0mB/node-distance-addon/commit/35b20fd)

**Changed package.json**

```diff
 â”Š 6â”Š 6â”Š  "repository": {
 â”Š 7â”Š 7â”Š    "type": "git",
 â”Š 8â”Š 8â”Š    "url": "https://github.com/DAB0mB/node-distance-addon.git"
+â”Š  â”Š 9â”Š  },
+â”Š  â”Š10â”Š  "scripts": {
+â”Š  â”Š11â”Š    "test": "node test"
 â”Š 9â”Š12â”Š  }
 â”Š10â”Š13â”Š}
```

Like I said in the introduction, it's a simple module which can calculate the distance between 2
given points. `calculate.sync` can do it synchronously and `calculate.async` can do it
asynchronously. Now that you got the idea we will start configuring our add-on.

The first thing you'll need to do is to make sure that you have `node-gyp` installed:

```bash
sudo npm install -g node-gyp
```

`node-gyp` is also dependent on many other packages, so before you go any further please take a look
at the official installation instructions in their
[README.md file](https://github.com/nodejs/node-gyp).

Assuming that you have installed everything properly, we will now need to create a `binding.gyp`
file:

### [Create `binding.gyp` File](https://github.com/DAB0mB/node-distance-addon/commit/ff44399)

**Added `binding.gyp`**

```diff
+â”Š  â”Š 1â”Š{
+â”Š  â”Š 2â”Š  "targets": [
+â”Š  â”Š 3â”Š    {
+â”Š  â”Š 4â”Š      "target_name": "distance",
+â”Š  â”Š 5â”Š      "sources": [
+â”Š  â”Š 6â”Š        "src/distance.cc"
+â”Š  â”Š 7â”Š      ],
+â”Š  â”Š 8â”Š      "include_dirs": ["<!(node -e \"require('nan')\")"]
+â”Š  â”Š 9â”Š    }
+â”Š  â”Š10â”Š  ]
+â”Š  â”Š11â”Š}ğŸš«â†µ
```

GYP stands for 'Generate Your Project' and was created by the Chromium team as a configuration file
for building native projects. The configuration show above should be a good template for any future
add-on you're looking to develop. Let's take a deeper look at it:

- `target_name` - Specifies the output dir of our add-on, in which case it should be
  `build/Release/distance`
- `sources` - Should include all the cpp files that are associated with you add-on.
- `include_dirs` - Additional dirs that should be included when building the add-on. If you'll run
  the given script in the terminal you'll get the node-module path for Nan, a library which we're
  interested in during the build process.

More information about GYP configuration can be found
[here](https://gyp.gsrc.io/docs/UserDocumentation.md).

Be sure to also add the specified flag to the `package.json` which basically says 'Hey, I have a GYP
file which should be taken into consideration as well':

### [Create `binding.gyp` File](https://github.com/DAB0mB/node-distance-addon/commit/ff44399)

**Changed `package.json`**

```diff
 â”Š 7â”Š 7â”Š    "type": "git",
 â”Š 8â”Š 8â”Š    "url": "https://github.com/DAB0mB/node-distance-addon.git"
 â”Š 9â”Š 9â”Š  },
+â”Š  â”Š10â”Š  "gypfile": true,
 â”Š10â”Š11â”Š  "scripts": {
 â”Š11â”Š12â”Š    "test": "node test"
 â”Š12â”Š13â”Š  }
```

Now we will add the following NPM scripts so whenever we run `npm run build` our project will be
built:

### [Add npm Build Scripts](https://github.com/DAB0mB/node-distance-addon/commit/a9a8815)

**Changed `.gitignore`**

```diff
+â”Š â”Š1â”Šbuild
 â”Š1â”Š2â”Šnode_modulesğŸš«â†µ
```

**Changed `package.json`**

```diff
 â”Š 9â”Š 9â”Š  },
 â”Š10â”Š10â”Š  "gypfile": true,
 â”Š11â”Š11â”Š  "scripts": {
+â”Š  â”Š12â”Š    "pre-publish": "npm run build",
+â”Š  â”Š13â”Š    "build": "node-gyp rebuild",
+â”Š  â”Š14â”Š    "test": "npm run build && node test"
 â”Š13â”Š15â”Š  }
 â”Š14â”Š16â”Š}
```

The only thing left to do before jumping into implementation would be installing Nan:

```bash
npm install nan --save
```

The basis for build process is set. We will create the entry file for our add-on:

### [Create Add-On Entry File](https://github.com/DAB0mB/node-distance-addon/commit/793e892)

**Added `src/distance.cc`**

```diff
+â”Š â”Š1â”Š#include <nan.h>
+â”Š â”Š2â”Š#include <v8.h>
+â”Š â”Š3â”Š
+â”Š â”Š4â”ŠNAN_MODULE_INIT(Init) {
+â”Š â”Š5â”Š
+â”Š â”Š6â”Š}
+â”Š â”Š7â”Š
+â”Š â”Š8â”ŠNODE_MODULE(distance, Init)ğŸš«â†µ
```

Every add-on should start with these two macro calls. They are both compiled into a piece of code
which will register our module with ease. The `NODE_MODULE` macro template accepts the name of the
target as the first argument (That one we set as `target_name` in the GYP file, remember?) and the
initialization method for our module. The `NAN_MODULE_INIT`generates a function with the given name.
It accepts `target` as the first argument which is equivalent to Node.js' `exports`. Now we will
create our first method stub for a synchronous distance calculation:

### [Create `CalculateSync` Method Stub](https://github.com/DAB0mB/node-distance-addon/commit/90e3c72)

**Changed `src/distance.cc`**

```diff
 â”Š 1â”Š 1â”Š#include <nan.h>
 â”Š 2â”Š 2â”Š#include <v8.h>
 â”Š 3â”Š 3â”Š
+â”Š  â”Š 4â”ŠNAN_METHOD(CalculateSync) {
+â”Š  â”Š 5â”Š
+â”Š  â”Š 6â”Š}
 â”Š 5â”Š 7â”Š
+â”Š  â”Š 8â”ŠNAN_MODULE_INIT(Init) {
+â”Š  â”Š 9â”Š  NAN_EXPORT(target, CalculateSync);
 â”Š 6â”Š10â”Š}
 â”Š 7â”Š11â”Š
 â”Š 8â”Š12â”ŠNODE_MODULE(distance, Init)ğŸš«â†µ
```

We exported the `CalculateSync` by using the `NAN_EXPORT` macro, and we used `NAN_METHOD` to define
a new node-valid function. It accepts `info` as the first argument, and it is the same as
JavaScript's `arguments` vector. We already know which arguments this function should accept, that's
why I followed TDD methodology from the first place:

### [Destructure Arguments Vector](https://github.com/DAB0mB/node-distance-addon/commit/ee1d560)

**Changed `src/distance.cc`**

```diff
 â”Š 1â”Š 1â”Š#include <nan.h>
 â”Š 2â”Š 2â”Š#include <v8.h>
 â”Š 3â”Š 3â”Š
+â”Š  â”Š 4â”Šusing Nan::To;
+â”Š  â”Š 5â”Šusing v8::Local;
+â”Š  â”Š 6â”Šusing v8::Object;
 â”Š 5â”Š 7â”Š
+â”Š  â”Š 8â”ŠNAN_METHOD(CalculateSync) {
+â”Š  â”Š 9â”Š  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();
+â”Š  â”Š10â”Š  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();
 â”Š 6â”Š11â”Š}
 â”Š 7â”Š12â”Š
 â”Š 8â”Š13â”ŠNAN_MODULE_INIT(Init) {
```

We use the `To()` function to convert the first argument into the desired type, and then we call the
method `ToLocalChecked()`. This method is simply going to convert the result into v8's Local, unless
the argument is undefined, in which case an error is going to be thrown. I like to prefix JS object
with a `js_` so I know with what kind variable I'm dealing with. We should have two points
containing `x` and `y` fields. Let's try to extract them out of the arguments vector and convert
them into native C++ structures:

### [Convert JS Objects to Native C++ Structures](https://github.com/DAB0mB/node-distance-addon/commit/81998eb)

**Changed `src/distance.cc`**

```diff
 â”Š 1â”Š 1â”Š#include <nan.h>
 â”Š 2â”Š 2â”Š#include <v8.h>
 â”Š 3â”Š 3â”Š
+â”Š  â”Š 4â”Šusing Nan::New;
 â”Š 4â”Š 5â”Šusing Nan::To;
 â”Š 5â”Š 6â”Šusing v8::Local;
 â”Š 6â”Š 7â”Šusing v8::Object;
+â”Š  â”Š 8â”Šusing v8::String;
+â”Š  â”Š 9â”Š
+â”Š  â”Š10â”Šstruct Point {
+â”Š  â”Š11â”Š  double x;
+â”Š  â”Š12â”Š  double y;
+â”Š  â”Š13â”Š};
 â”Š 7â”Š14â”Š
 â”Š 8â”Š15â”ŠNAN_METHOD(CalculateSync) {
 â”Š 9â”Š16â”Š  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();
 â”Š10â”Š17â”Š  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();
+â”Š  â”Š18â”Š
+â”Š  â”Š19â”Š  Point* pointA = new Point();
+â”Š  â”Š20â”Š  pointA->x = To<double>(js_pointA->Get(New<String>("x").ToLocalChecked())).FromJust();
+â”Š  â”Š21â”Š  pointA->y = To<double>(js_pointA->Get(New<String>("y").ToLocalChecked())).FromJust();
+â”Š  â”Š22â”Š
+â”Š  â”Š23â”Š  Point* pointB = new Point();
+â”Š  â”Š24â”Š  pointB->x = To<double>(js_pointB->Get(New<String>("x").ToLocalChecked())).FromJust();
+â”Š  â”Š25â”Š  pointB->y = To<double>(js_pointB->Get(New<String>("y").ToLocalChecked())).FromJust();
 â”Š11â”Š26â”Š}
 â”Š12â”Š27â”Š
 â”Š13â”Š28â”ŠNAN_MODULE_INIT(Init) {
```

Then again we convert the `To()` function to convert the result into the desired data-type, only
this time it's a primitive, so we use `FromJust()` instead of `ToLocalChecked()`. Note that v8 only
uses double precision rather than a floating point. We can fetch properties from a given JS object
with ease using the `Get()` method. Pay attention to use the `->` rather than a period because
remember, a Local is actually a pointer! It is not the actual object.

Now all is left to do is defining the return value. Keep in mind that the value should be returned
through v8's current scope, not natively, so using the `return` keyword would be useless. The return
value can actually be defined through the provided `info` argument, like this:

### [Add Return Value to `CalculateSync` Method](https://github.com/DAB0mB/node-distance-addon/commit/1d6a7f6)

**Changed `src/distance.cc`**

```diff
 â”Š23â”Š23â”Š  Point* pointB = new Point();
 â”Š24â”Š24â”Š  pointB->x = To<double>(js_pointB->Get(New<String>("x").ToLocalChecked())).FromJust();
 â”Š25â”Š25â”Š  pointB->y = To<double>(js_pointB->Get(New<String>("y").ToLocalChecked())).FromJust();
+â”Š  â”Š26â”Š
+â”Š  â”Š27â”Š  info.GetReturnValue().Set(CalculateDistance(pointA, pointB));
 â”Š26â”Š28â”Š}
 â”Š27â”Š29â”Š
 â”Š28â”Š30â”ŠNAN_MODULE_INIT(Init) {
```

And of-course it requires us to add the core distance calculation method:

### [Add Core Distance Calculation Method](https://github.com/DAB0mB/node-distance-addon/commit/5af3b3d)

**Changed `src/distance.cc`**

```diff
+â”Š  â”Š 1â”Š#include <cstdlib>
+â”Š  â”Š 2â”Š#include <cmath>
 â”Š 1â”Š 3â”Š#include <nan.h>
 â”Š 2â”Š 4â”Š#include <v8.h>
 â”Š 3â”Š 5â”Š
 â”Š 4â”Š 6â”Šusing Nan::New;
 â”Š 5â”Š 7â”Šusing Nan::To;
+â”Š  â”Š 8â”Šusing std::pow;
+â”Š  â”Š 9â”Šusing std::sqrt;
 â”Š 6â”Š10â”Šusing v8::Local;
 â”Š 7â”Š11â”Šusing v8::Object;
 â”Š 8â”Š12â”Šusing v8::String;
```

```diff
 â”Š12â”Š16â”Š  double y;
 â”Š13â”Š17â”Š};
 â”Š14â”Š18â”Š
+â”Š  â”Š19â”Šdouble CalculateDistance(Point* pointA, Point* pointB) {
+â”Š  â”Š20â”Š  return sqrt(pow(pointA->x - pointB->x, 2) + pow(pointA->y - pointB->y, 2));
+â”Š  â”Š21â”Š}
+â”Š  â”Š22â”Š
 â”Š15â”Š23â”ŠNAN_METHOD(CalculateSync) {
 â”Š16â”Š24â”Š  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();
 â”Š17â”Š25â”Š  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();
```

This is it for the synchronous calculation. Now we will add an async version of it. We will start by
creating a method with everything we learned so far until the point where we have to return the
result:

### [Create `CalculateAsync` Method with Basic Deconstructuring](https://github.com/DAB0mB/node-distance-addon/commit/2711bf5)

**Changed `src/distance.cc`**

```diff
 â”Š35â”Š35â”Š  info.GetReturnValue().Set(CalculateDistance(pointA, pointB));
 â”Š36â”Š36â”Š}
 â”Š37â”Š37â”Š
+â”Š  â”Š38â”ŠNAN_METHOD(CalculateAsync) {
+â”Š  â”Š39â”Š  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();
+â”Š  â”Š40â”Š  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();
+â”Š  â”Š41â”Š
+â”Š  â”Š42â”Š  Point* pointA = new Point();
+â”Š  â”Š43â”Š  pointA->x = To<double>(js_pointA->Get(New<String>("x").ToLocalChecked())).FromJust();
+â”Š  â”Š44â”Š  pointA->y = To<double>(js_pointA->Get(New<String>("y").ToLocalChecked())).FromJust();
+â”Š  â”Š45â”Š
+â”Š  â”Š46â”Š  Point* pointB = new Point();
+â”Š  â”Š47â”Š  pointB->x = To<double>(js_pointB->Get(New<String>("x").ToLocalChecked())).FromJust();
+â”Š  â”Š48â”Š  pointB->y = To<double>(js_pointB->Get(New<String>("y").ToLocalChecked())).FromJust();
+â”Š  â”Š49â”Š}
+â”Š  â”Š50â”Š
 â”Š38â”Š51â”ŠNAN_MODULE_INIT(Init) {
 â”Š39â”Š52â”Š  NAN_EXPORT(target, CalculateSync);
+â”Š  â”Š53â”Š  NAN_EXPORT(target, CalculateAsync);
 â”Š40â”Š54â”Š}
 â”Š41â”Š55â”Š
 â”Š42â”Š56â”ŠNODE_MODULE(distance, Init)ğŸš«â†µ
```

Here's the different part. We don't wanna simply return the value, we want to make the calculations
in parallel with the event loop, and once we're finished we will interact with it once again. In our
model there are two threads. The first thread is the event loop thread, and the second thread will
be a worker thread managed by Nan, the library supports asynchronous I/O in NodeJS. Let's start
implementing and I will give some more explanations as we go further:

### [Queue Distance Worker](https://github.com/DAB0mB/node-distance-addon/commit/34f4a5d)

**Changed `src/distance.cc`**

```diff
 â”Š 3â”Š 3â”Š#include <nan.h>
 â”Š 4â”Š 4â”Š#include <v8.h>
 â”Š 5â”Š 5â”Š
+â”Š  â”Š 6â”Šusing Nan::AsyncQueueWorker;
+â”Š  â”Š 7â”Šusing Nan::AsyncWorker;
+â”Š  â”Š 8â”Šusing Nan::Callback;
 â”Š 6â”Š 9â”Šusing Nan::New;
 â”Š 7â”Š10â”Šusing Nan::To;
 â”Š 8â”Š11â”Šusing std::pow;
 â”Š 9â”Š12â”Šusing std::sqrt;
+â”Š  â”Š13â”Šusing v8::Function;
 â”Š10â”Š14â”Šusing v8::Local;
 â”Š11â”Š15â”Šusing v8::Object;
 â”Š12â”Š16â”Šusing v8::String;
```

```diff
 â”Š38â”Š42â”ŠNAN_METHOD(CalculateAsync) {
 â”Š39â”Š43â”Š  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();
 â”Š40â”Š44â”Š  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();
+â”Š  â”Š45â”Š  Callback* callback = new Callback(info[2].As<Function>());
 â”Š41â”Š46â”Š
 â”Š42â”Š47â”Š  Point* pointA = new Point();
 â”Š43â”Š48â”Š  pointA->x = To<double>(js_pointA->Get(New<String>("x").ToLocalChecked())).FromJust();
```

```diff
 â”Š46â”Š51â”Š  Point* pointB = new Point();
 â”Š47â”Š52â”Š  pointB->x = To<double>(js_pointB->Get(New<String>("x").ToLocalChecked())).FromJust();
 â”Š48â”Š53â”Š  pointB->y = To<double>(js_pointB->Get(New<String>("y").ToLocalChecked())).FromJust();
+â”Š  â”Š54â”Š
+â”Š  â”Š55â”Š  AsyncQueueWorker(new DistanceWorker(callback, pointA, pointB));
 â”Š49â”Š56â”Š}
 â”Š50â”Š57â”Š
 â”Š51â”Š58â”ŠNAN_MODULE_INIT(Init) {
```

Here we fetch the third argument which is the callback. We wrap it with Nan's Callback, which will
make sure it is not garbage collected once the scope is being deleted, we want it to keep living
until it's not relevant. At the bottom of the method, instead of returning a value explicitly, we
queue our `DistanceWorker` into the workers queue. On that note, let's implement the DistanceWorker:

### [Create `DistanceWorker` with a Constructor and a Deconstructor](https://github.com/DAB0mB/node-distance-addon/commit/8bbd87f)

**Changed `src/distance.cc`**

```diff
 â”Š24â”Š24â”Š  return sqrt(pow(pointA->x - pointB->x, 2) + pow(pointA->y - pointB->y, 2));
 â”Š25â”Š25â”Š}
 â”Š26â”Š26â”Š
+â”Š  â”Š27â”Šclass DistanceWorker : public AsyncWorker {
+â”Š  â”Š28â”Š private:
+â”Š  â”Š29â”Š  Point* pointA;
+â”Š  â”Š30â”Š  Point* pointB;
+â”Š  â”Š31â”Š
+â”Š  â”Š32â”Š public:
+â”Š  â”Š33â”Š  DistanceWorker(Callback* callback, Point* pointA, Point* pointB) :
+â”Š  â”Š34â”Š    AsyncWorker(callback), pointA(pointA), pointB(pointB) {}
+â”Š  â”Š35â”Š
+â”Š  â”Š36â”Š  ~DistanceWorker() {
+â”Š  â”Š37â”Š    delete pointA;
+â”Š  â”Š38â”Š    delete pointB;
+â”Š  â”Š39â”Š  }
+â”Š  â”Š40â”Š
+â”Š  â”Š41â”Š  void Execute () {
+â”Š  â”Š42â”Š
+â”Š  â”Š43â”Š  }
+â”Š  â”Š44â”Š
+â”Š  â”Š45â”Š  void HandleOKCallback () {
+â”Š  â”Š46â”Š
+â”Š  â”Š47â”Š  }
+â”Š  â”Š48â”Š};
+â”Š  â”Š49â”Š
 â”Š27â”Š50â”ŠNAN_METHOD(CalculateSync) {
 â”Š28â”Š51â”Š  Local<Object> js_pointA = To<Object>(info[0]).ToLocalChecked();
 â”Š29â”Š52â”Š  Local<Object> js_pointB = To<Object>(info[1]).ToLocalChecked();
```

`AsyncWorker` is an abstract class that you can subclass to have much of the annoying asynchronous
queuing and handling taken care of for you. It can even store arbitrary v8 objects for you and have
them persist while the asynchronous work is in progress. The `execute()` method is being executed
inside the worker-thread. It is not safe to access V8, or V8 data structures there, so everything we
need for input and output should go on 'this'. The `HandleOKCallback()` method is executed when the
async work is complete. This function will be run inside the main event loop, so it is safe to use
v8 again. Let's implement the core distance calculation on the worker thread:

### [Execute Distance Calculation](https://github.com/DAB0mB/node-distance-addon/commit/9cd18e8)

**Changed `src/distance.cc`**

```diff
 â”Š26â”Š26â”Š
 â”Š27â”Š27â”Šclass DistanceWorker : public AsyncWorker {
 â”Š28â”Š28â”Š private:
+â”Š  â”Š29â”Š  double distance;
 â”Š29â”Š30â”Š  Point* pointA;
 â”Š30â”Š31â”Š  Point* pointB;
 â”Š31â”Š32â”Š
```

```diff
 â”Š39â”Š40â”Š  }
 â”Š40â”Š41â”Š
 â”Š41â”Š42â”Š  void Execute () {
+â”Š  â”Š43â”Š    distance = CalculateDistance(pointA, pointB);
 â”Š43â”Š44â”Š  }
 â”Š44â”Š45â”Š
 â”Š45â”Š46â”Š  void HandleOKCallback () {
```

And handle a successful invocation once the calculation is finished:

### [Handle Successful Invokation](https://github.com/DAB0mB/node-distance-addon/commit/8dd60ff)

**Changed `src/distance.cc`**

```diff
 â”Š 6â”Š 6â”Šusing Nan::AsyncQueueWorker;
 â”Š 7â”Š 7â”Šusing Nan::AsyncWorker;
 â”Š 8â”Š 8â”Šusing Nan::Callback;
+â”Š  â”Š 9â”Šusing Nan::HandleScope;
 â”Š 9â”Š10â”Šusing Nan::New;
+â”Š  â”Š11â”Šusing Nan::Null;
 â”Š10â”Š12â”Šusing Nan::To;
 â”Š11â”Š13â”Šusing std::pow;
 â”Š12â”Š14â”Šusing std::sqrt;
 â”Š13â”Š15â”Šusing v8::Function;
 â”Š14â”Š16â”Šusing v8::Local;
+â”Š  â”Š17â”Šusing v8::Number;
 â”Š15â”Š18â”Šusing v8::Object;
 â”Š16â”Š19â”Šusing v8::String;
+â”Š  â”Š20â”Šusing v8::Value;
 â”Š17â”Š21â”Š
 â”Š18â”Š22â”Šstruct Point {
 â”Š19â”Š23â”Š  double x;
```

```diff
 â”Š44â”Š48â”Š  }
 â”Š45â”Š49â”Š
 â”Š46â”Š50â”Š  void HandleOKCallback () {
+â”Š  â”Š51â”Š    HandleScope scope;
 â”Š47â”Š52â”Š
+â”Š  â”Š53â”Š    Local<Value> argv[] = {
+â”Š  â”Š54â”Š      Null(),
+â”Š  â”Š55â”Š      New<Number>(distance)
+â”Š  â”Š56â”Š    };
+â”Š  â”Š57â”Š
+â”Š  â”Š58â”Š    callback->Call(2, argv);
 â”Š48â”Š59â”Š  }
 â”Š49â”Š60â”Š};
```

Normally, when defining a NodeJS method (`NAN_METHOD` macro) a scope will be created for us
automatically. In this function's context there is no scope exist, so we will have to create it
using the `HandleScope` deceleration (The current scope is stored globally so even though we don't
use it explicitly, v8 and Nan know what to do). We also created an arguments vector as the return
value, following Node.js' conventions, the first argument would be the error and the second argument
would be the result.

This is it! Finally, we will transform the add-on into a nicer looking node-module:

### [Transform Add-On into a Nicer Looking Node Module](https://github.com/DAB0mB/node-distance-addon/commit/a250013)

**Added `index.js`**

```
+â”Š â”Š1â”Šconst Distance = require('./build/Release/distance');
+â”Š â”Š2â”Š
+â”Š â”Š3â”Šexports.calculate = {
+â”Š â”Š4â”Š  sync: Distance.CalculateSync,
+â”Š â”Š5â”Š  async: Distance.CalculateAsync
+â”Š â”Š6â”Š};ğŸš«â†µ
```

And now, let's run our small test to see that it works, using the following command:

```bash
npm run test
```

If everything went well, you should have the following messages printed to the terminal:

```
sync calculation passed
async calculation passed
```

---

## What's Next?

You've just learned the very basics of how to use C++ within NodeJS. There's a lot more to learn
when it comes to building an add-on, and I'm not just talking about learning v8 and Nan's API. Think
about the possibilities, the C++ community have been developed for years and there are so much great
libraries out there that are not necessarily relevant to NodeJS due to its efficiency, like
[Boost](https://boost.org), [OpenCV](https://opencv.org), [CGAL](https://cgal.org) and many more.

- Check out the full project of this tutorial:
  [https://github.com/DAB0mB/node-distance-addon](https://github.com/DAB0mB/node-distance-addon)
- Check out this awesome framework for creating tutorials by Urigo, which helped me to make this
  nicely structured tutorial: [https://github.com/Urigo/tortilla](https://github.com/Urigo/tortilla)
