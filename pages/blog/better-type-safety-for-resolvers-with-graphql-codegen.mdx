import withArticle from '../../ui/blog/article';

export const meta = {
  title: 'Better Type Safety for your GraphQL resolvers with GraphQL Codegen',
  tags: ['graphql', 'codegen', 'node', 'typescript'],
  author: 'dotan',
  date: '2020-05-17',
  description:
    'Type-check your resovlers implementation in order to find issues in build-time.',
  image: '/blog-assets/graphql-code-generator/cover.png',
};
const embedOptions = {
  theme: 'light',
  view: 'editor',
  previewwindow: 'console',
};

export default withArticle({ ...meta });

If you use TypeScript to write your GraphQL schema implementation, you'll love the integration with GraphQL Codegen and `typescript-resolvers` plugin.

This plugin allow you to easily have typings for your resolvers, with super flexible configuration that allow you to integrate it easily to your existing code, typed and models.

Having type check on your resovlers can help to improve your code quality, detect issues in build time (instead of runtime), and improve developer experience.

## Getting Started

If you are already familiar with [GraphQL Code Generator](http://graphql-code-generator.com/), you can skip this step.

Start by installing GraphQL Codegen and the relevant plugins:

```
yarn add @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-resolvers
```

Now, create `codegen.yml` file with the following, make sure to point to your schema location:

```yaml
schema: YOUR_SCHEMA_LOCATION_HERE
generates:
  ./resolvers-types.ts:
    plugins:
      - typescript
      - typescript-resolvers
```

> GraphQL Code Generator uses `graphql-tools` so you can point to your schema files, or `/graphql` endpoint.

To run GraphQL Codegen, use: `yarn graphql-codegen` (or, create a script for it if you wish). This should create a new file called `resolvers-types.ts` in your codebase.

## Simple Resolvers Signature

In this example, we'll use the following GraphQL schema and resolvers as reference. [You can find a working live-demo of this part here](https://codesandbox.io/s/condescending-albattani-ixyp9?file=/resolvers.ts).

<CodeSandbox
  codeSandboxId={'condescending-albattani-ixyp9'}
  size={'300px'}
  embedOptions={{ ...embedOptions, module: '/schema.graphql' }}
/>

This is a naive implementation of a GraphQL API, and we'll see how more advanced use cases could be implemented in the upcoming steps.

To get started with the generated files, import `Resolvers` identifier from your generated file, and use it to type your resolvers object, for example:

<CodeSandbox
  codeSandboxId={'condescending-albattani-ixyp9'}
  size={'410px'}
  embedOptions={{
    ...embedOptions,
    module: '/resolvers.ts,/schema.graphql,/resolvers-types.ts',
  }}
/>

Now, TypeScript engine will verify that object you returned, and you'll be able to see that if you'll change one of the fields, it will be type checked immediately:

<Gfycat gifId={'accurateunfitconure'} />

Also, if you'll change your schema types and re-run the codegen (or use [Watch Mode](https://graphql-code-generator.com/docs/getting-started/development-workflow#watch-mode)), it will re-generate the matching types and check your code again.

As your probably understood, the default behaviour of `typescript-resolvers` is using the base type generated by `typescript`, that means, that your schema types and resolvers needs to match and have the same signature and structure.

But it's not always the case - because your GraphQL schema, in most cases, isn't the same as your models types - this is why we have `mappers` configuration.

## Use Your Model Types

To use `mappers` configuration, we need first to setup a real type safety, and have models types for our actual objects.

Let's assumes that your backend is implemented this way, with some models types:

<CodeSandbox
  codeSandboxId={'silly-kalam-ym77z'}
  size={'330px'}
  embedOptions={{ ...embedOptions, module: '/models.ts' }}
/>

It means that now, your resolvers implementation needs to adjusted and handle the different data structure:

<CodeSandbox
  codeSandboxId={'silly-kalam-ym77z'}
  size={'400px'}
  embedOptions={{ ...embedOptions, module: '/resolvers-with-error.ts' }}
/>

Noticed the errors? it caused by the fact that we don't have the appropriate mapping set yet. We need to tell GraphQL codegen that our schema types are different than the model types.

To do that, let's update codegen config with `mappers` and add a mapping between a GraphQL type to a TypeScript type (and the file it's located in):

<CodeSandbox
  codeSandboxId={'silly-kalam-ym77z'}
  size={'400px'}
  embedOptions={{ ...embedOptions, module: '/codegen-with-mappers.yml' }}
/>

This way, GraphQL Codegen will use your custom models types in the generated output, instead of the default types, and your resolvers implementation will look like that:

<CodeSandbox
  codeSandboxId={'silly-kalam-ym77z'}
  size={'400px'}
  embedOptions={{ ...embedOptions, module: '/resolvers.ts' }}
/>

Note that now you'll get autocomplete, type safety and a better connection between your GraphQL schema and your GraphQL resolvers:

<Gfycat gifId={'perfumedillegalbee'} />

## Typed Context

`typescript-resolvers` also supports replacing the `context` type of your resolvers implementation. All you have to do, is to add this following to your codegen configuration:

```yml
schema: schema.graphql
generates:
  ./resolvers-types.ts:
    config:
      contextType: models#MyContextType
      mappers:
        User: ./models#UserModel
        Profile: ./models#UserProfile
    plugins:
      - typescript
      - typescript-resolvers
```

This will make sure to replace `any` with `MyContextType`, and you'll be able to access a fully-typed `context` object in your resolvers.

## What's next?

A few notes that worth mentioning:

- You can use `mappers` on every GraphQL type, interface or a union.
- Your resolvers' arguments (`args`) are also fully-typed, according to your schema definition.
- The `parent` value is also fully typed, based on your `mappers`.
- You can import your types from a node module package (`User: models-lib#UserType`).
- You can also map to built-in language types (`DateType: Date`)
- Aliasing the imports is also possible (`User: ./models#User as MyCustomUserType`)

You can also modify the default mapper (`defualtMapper`) and allow partial resolution, this will allow you to return partial objects in every resolver ([more info](https://github.com/dotansimha/graphql-code-generator/issues/1133#issuecomment-456812621)):

```yaml
config:
  useIndexSignature: true
  defualtMapper: Partial<{T}>
```

For more advanced use-cases, you can find [the complete plugin documentation here](https://graphql-code-generator.com/docs/plugins/typescript-resolvers/#configuration).
