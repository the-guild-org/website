import withArticle from '../../ui/blog/article'
export const meta = {
  title: 'Caching data with DataLoader',
  author: 'giladtidhar',
  tags: ['cache', 'data', 'server', 'graphql'],
  date: '2022-1-12',
  description: 'How to use DataLoader to cache data',
  image: '/blog-assets/caching-data-with-dataloader/cover.png'
}
export default withArticle({ ...meta })

# Caching

Caching is an essential part of designing scalable and performant GraphQL API.

But, what is caching?
Caching is the technical design of trying to avoid compute-intensive tasks by keeping their results temporarily in a cache.
A cache is a place in memory for important data, which can be delivered to the client faster than the regular procedure.

For example, for a GraphQL API, we might want to cache a field value that comes from a slow external API.
The goal of caching is to improve performance where itâ€™s needed the most.

## How is caching faster?

Using a cache for compute-intensive data is faster for a few reasons:

- A cache is usually not stored in storage, but in memory, which is a few times faster.
- A cache is smaller than a database, so there are a lot less values to filter through.
- While some cached data might be queried a lot of times, it will be fetched from the database only one time, so there's less time lost for fetching multiple times.

# How do we use caching?

## Caching with `dataloader`

My prefered platform for caching is dataloader, and in this tutorial I will explain how to use dataloader with Node.js and Typescript, to have caching in your server.

:::tip `dataloader` outside of GraphQL

The `dataloader` package was created specifically for GraphQL, but it can work with other Node.js programs.

:::

## Using dataloader

### 1. Install dataloader in your project

Install `dataloader` by running the following:

`npm install --save dataloader` or `yarn add dataloader`

### 2. Import `dataloader`

To start, import `dataloader` and LRU (LRU is a cache algorithm that will put only the most _X_ requested items in the cache).

```ts
import DataLoader from 'dataloader'
import { LRUMap } from 'lru_map'
```

### 3. Define the types that would be saved to our cache

The first type should be a way to represent the data, like a string with a name, and the other is the data itself.

```ts
type PackageName = string
type PackageInfo = DataType // note that this is the type of the data we represent.
//for example:
type DataType = {
  id: string
  name: string
  description?: string
}
```

### 4. Create the dataloader instant

````ts
const dataLoader = new DataLoader<PackageName, PackageInfo>(
  async (/* (1) */keys: readonly PackageName[]) => { /* (2) */
    return await Promise.all(
      keys.map((packageName) => {
        getData(packageName).catch((e) => e);
      })
    );
  },{
    cacheMap: new LRUMap(100); /* (3) */
  }
);

As you can see, we give the keys that the user asks for to the dataloader (1).

I recommend setting the keys to be some kind of id for the following reason:
Lets say that in your api, the user asks for data using its id, so the user will fetch with `id:"something"`, you could just pass the id as the key, instead of changing it.

The dataloader will first check if it has the keys on cache, and if so, it would return the data, without going through the database.

After that (2), we give the dataloader a function for fetching the data, in case it doesn't have it in the cache.
In this case, I have the function `getData`, and I'm using the keys to "get data" from my database.

In the end (3) we give it cacheMap and some value, the value represents how many queries dataloader will cache, in this case, after a 100 values, it will delete the first value to make space for the 101th value.

From now, to query data, you just run

```ts
dataLoader.load(keys)
````

# Dataloader with GraphQL

Dataloader was designed to work with GraphQL, to solve the [n+1 problem](https://medium.com/the-marcy-lab-school/what-is-the-n-1-problem-in-graphql-dd4921cb3c1a)

## How to use the dataloader package with GraphQL?

To use the dataloader with GraphQL just pass it in the context!

```ts
import DataLoader from "dataloader";
type PackageName = string;
type PackageInfo = Package;
export type GraphQLContext = {
  dataLoader: DataLoader<PackageName, PackageInfo>;
  ...
};
const dataLoader = new DataLoader<PackageName, PackageInfo>(
  async (keys: readonly PackageName[]) => {
    return await Promise.all(
      keys.map((packageName) => {
        npmApi.getPackage(packageName).catch((e) => e)
      })
    );
  },
  {
    cacheMap: new LRUMap(100),
  }
);
...
export async function contextFactory() {
  return { dataLoader, ... };
}
```

Now, in your resolvers, just call `context.dataLoader.load(keys)` and that's it! You now have caching in your server!
