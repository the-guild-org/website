import withArticle from '../../ui/blog/article';

export const meta = {
  title: 'Manage Circular Imports Hell in GraphQL-Modules',
  tags: [],
  date: '2019-3-18',
  description: 'TODO:',
  image:
    'https://github.com/the-guild-org/oneblog/blob/master/img/704/0*GtvTnhPxwZKLWiO1.png?raw=true',
};

export default withArticle({ ...meta });

Designing and building modular GraphQL API may not look straight-forward the first time you start. It is hard to keep a perfect modularity with standalone and encapsulated modules.

It is really easy to appeal to the circular imports, but that’s exactly what you shouldn’t do in any case. You might say while reading this; **_I DON’T HAVE ANY WAY OF NOT CREATING CIRCULAR IMPORTS_**!

In a previous versions of GraphQL-Modules, we used to allow users to have circular imports in their GraphQL-Modules applications. However, it created a lot of extra logic which slows down the initial schema generation speed, because we always need to check if there is circular imports between modules.

Then, if GraphQL-Modules found some, it would **merge** all the members of this **circular import** into a one **LARGE MODULE** which was **breaking almost every principle of encapsulation and modularity** we mentioned in previous blog-posts of our GraphQL-Modules series.

Finally, we decided to **remove this** support; then **force** people to have **strict modularity** in their projects.

[https://medium.com/the-guild/why-is-true-modular-encapsulation-so-important-in-large-scale-graphql-projects-ed1778b03600](https://medium.com/the-guild/why-is-true-modular-encapsulation-so-important-in-large-scale-graphql-projects-ed1778b03600 'Why is True Modular Encapsulation So Important in Large-Scale GraphQL Projects?
How GraphQL Modules helps you encapsulate the different parts of your code, so it will be easier to manage when your…medium.com')

Forcing people out of a way of developing is always hard and we’ve got [questions from you](https://github.com/Urigo/graphql-modules/issues/317) about how to solve some specific issues — so in this blog post and new doc section we will help you understand why this was a bad practice and how to migrate from it with different use cases.

## The Problem

Let’s assume we have 3 different entities in our database;

- User
- Post
- Comment

Then, if we create three different modules for these three entities;

```graphql
type User {
  id: ID
  name: String
  username: String
  email: String
  ## Some other fields
  posts: [Post]
  comments: [Comment]
}
```

```graphql
type Post {
  id: ID
  title: String
  content: String
  user: User
  comments: [Comment]
}
```

```graphql
type Comment {
  id: ID
  content: String
  user: User
  post: Post
}
```

As you can see above, every module imports other modules; and this creates a circular dependency.

You might ask if this is the only way to implement modules for these entities; because it looks like there is no point to have different modules for those schemas. Having circular dependency is the same situtation with having a single large module.

![](https://github.com/the-guild-org/oneblog/blob/master/img/704/1*2Yeuig2ffEYQmXY2sQfG5A.gif?raw=true)

## How To Solve

Let’s see what we have in terms of relationship; - `User` doesn’t depend on `Post` and `Comment` - `Post` doesn’t depend on `Comment`.

\- `Comment` depends on `User` and `Post`, because it has `userId` and `postId` fields - `Post` also depends on `User` because it has `userId` field

So let’s create modules in that way,

```graphql
type User {
 id: ID
 name: String
 username: String
 email: String
 ## Some other fields
}
```

```graphql
type Post {
 id: ID
 title: String
 content: String
 user: User
}
extend type User {
 posts: [Post]
}
```

```graphql
type Comment {
 id: ID
 content: String
 user: User
 post: Post
}
extend type Post {
 comments: [Comment]
}
extend type User {
 comments: [Comment]
}
```

> Using this approach, you will have standalone modules; otherwise will create a big module which contains all of them like we used to handle circular deps in this way (**merging all circular imports**).

Also `extend` says that it needs a main definition from imported modules which makes the connection more readable in terms of entity relations.

---

## All posts about GraphQL Modules

1.  [GraphQL Modules — Feature based GraphQL Modules at scale](https://medium.com/the-guild/graphql-modules-feature-based-graphql-modules-at-scale-2d7b2b0da6da)

1.  [Why is True Modular Encapsulation So Important in Large-Scale GraphQL Projects?](https://medium.com/the-guild/why-is-true-modular-encapsulation-so-important-in-large-scale-graphql-projects-ed1778b03600)

1.  [Why did we implement our own Dependency Injection library for GraphQL-Modules?](https://medium.com/p/f25a234a9762)

1.  [Scoped Providers in GraphQL-Modules Dependency Injection](https://medium.com/p/949cd2588e0)

1.  [Writing a GraphQL TypeScript project w/ GraphQL-Modules and GraphQL-Code-Generator](https://medium.com/the-guild/writing-strict-typed-graphql-typescript-project-w-graphql-modules-and-graphql-code-generator-c22f6caa17b8)

1.  [Authentication and Authorization in GraphQL (and how GraphQL-Modules can help)](https://medium.com/the-guild/authentication-and-authorization-in-graphql-and-how-graphql-modules-can-help-fadc1ee5b0c2)

1.  [Authentication with AccountsJS & GraphQL Modules](https://medium.com/the-guild/authentication-with-accountsjs-graphql-modules-e0fb9799a9da)

1.  [Manage Circular Imports Hell with GraphQL-Modules](https://medium.com/the-guild/manage-circular-imports-hell-with-graphql-modules-4b1611dee781)
