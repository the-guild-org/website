import withArticle from '../../ui/blog/article'

export const meta = {
  title: 'KitQL & Houdini projects are joining forces',
  tags: ['graphql', 'svelte'],
  authors: ['jycouet', 'alecAivazis'],
  date: '2022-07-04',
  description:
    "After a few months of discussing, experimenting and testing, it's about time to explain how KitQL and Houdini are working together from now!",
  image: '/blog-assets/houdini-and-kitql/2022 05 25 - KitQL & Houdini.gif',
  thumbnail: '/blog-assets/houdini-and-kitql/thumbnail.png'
}

export default withArticle(meta)

## Motivations

SvelteKit is an excellent alternative to all popular frameworks and simplifies the creation of "WebApp"
_(put what you want behind this term ^^)_.
Houdini and KitQL were created to manage GraphQL in this environment to use
_(and abuse!)_ the new way of programming as much as possible.

A few months back, [Alec](https://twitter.com/AlecAivazis) and [Jean-Yves](https://twitter.com/jycouet) meet and
we had a very open discussion about our libraries, pros & cons about different approaches and one question keep coming back:

> How to provide the best experience of #Svelte with #GraphQL to the community?

Where do we stand today?

### General

- We were not satisfied by Apollo or URQL client that are quite generic. Not ideal to unlock all the power of svelte!

### Houdini key points

- Inline documents with preprocessor that avoids a lot of boilerplate code for the user
- A simple and effective normalized cache
- Out of the box features like Pagination, List
- Optimistic UI / Partial
- Client scalar
- Fragment masking to get collocated code
- Subscription

> Focus on the client part of GraphQL

### KitQL key points

- External documents working well with all the graphql ecosystem
- Stores per operation
- Query cache
- Debugging widget
- Making us of existing tools (Yoga / Envelop / Modules / Scalars / CodeGen / eslint / ...)

> Focus on making a full-stack app with GraphQL

### Summary

Seeing all this, we decided to join forces.
KitQL will move client related things in Houdini.

Like this, if you are looking for:

- a GraphQL client, we recommend to use Houdini.
- building a full-stack app, we recommend KitQL _(including Houdini of course ðŸ˜‰)_

> And it's effective Today!!! ðŸ¥³ðŸ¥³ðŸ¥³

## How it looks like to use GraphQL in SvelteKit?

You have now two ways that you can mix and match in your application:

### External Documents

You write your GraphQL query in an external file `AllItems.gql` like:

```graphql
query AllItems {
  items {
    id
    name
  }
}
```

And you can use the generated store everywhere in your app like:

```svelte
<script lang="ts">
  import { GQL_AllItems } from '$houdini'

  $: browser && GQL_AllItems.fetch()
</script>

{#each $GQL_AllItems.data.items as item}
  {item.name}
{/each}
```

Pretty simple, right? You can put this code in a component or in a route.
Here, you are doing `CSR` (Client Side Rendering), the browser is doing a network call to get data.

If you want to enjoy `SSR` (Server Side Rendering), you have to add a bit your code as follow.
FYI, `SSR` means that on the first load of the page the server will get the data and put it directly in your html.
And when you navigate from the client already, we fallback automatically in `CSR` mode.
But don't worry, it's the default behavior of SvelteKit!

This code is to be added in the route page where you want SSR data.

```svelte
<script context="module" lang="ts">
  export async function load(event: LoadEvent) {
    await GQL_AllItems.fetch({ event });
    return {};
  }
</script>
```

### Inline Documents

With inline documents, the approache is a bit different but relies on the same store API under the hood.
Here is what your write, and you get automagically `CSR` and `SSR` depending on where you are!

```svelte
<script>
    import { query, graphql } from '$houdini'

    const { data } = query(graphql`
        query AllItems {
            items {
                id
                name
            }
        }
    `)
</script>

{#each $data.items as item}
    <div>{item.name}</div>
{/each}
```

### All features are available for both way of working

#### Pagination example

For example, you want to do an infinite scroll pagination? And load more items?
Simply do ðŸ‘‡

```svelte
<script lang="ts">
    function loadMore() {
        await GQL_AllItems.loadMore()
    }
</script>

<button on:click={loadMore}>Load More</button>

{#each $GQL_AllItems.data.items as item}
    {item.title}
{/each}
```

And that's it!

#### Mutation example to append the list

First, you need to inform graphql that this is a "special" list with a directive.

```graphql
query AllItems {
  items @list(name: "All_Items") {
    id
    name
  }
}
```

Then, call your mutation and that's it! No need to retrigger a query to get the new data in the list, No need to append the list manually!

```svelte
<script lang="ts">
  const mutate = mutation<AddItem>(graphql`
    mutation AddItem($name: String!) {
      addItem(name: $name) {
        ...All_Items_insert
      }
    }
  `);

  function add() {
    mutate({ name: 'my new item name' });
  }
</script>

<button on:click={add}>Add</button>

{#each $GQL_AllItems.data.items as item}
    {item.title}
{/each}
```

## Now what?

If you were a Houdini user, please follow the dedicated [migration guide]()

If you were a KitQL user, please follow the dedicated [migration guide]()

If you are new to all this, you are welcome too ðŸ˜‰
Please come and enjoy the two projects on GitHub [Houdini](https://github.com/HoudiniGraphql/houdini) and [KitQL](https://www.kitql.dev/)

Speak to you soon!
