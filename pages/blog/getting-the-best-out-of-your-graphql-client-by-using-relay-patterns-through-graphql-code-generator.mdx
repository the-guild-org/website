import withArticle from '../../ui/blog/article'

export const meta = {
  title:
    'Getting the best out of your GraphQL client by using Relay patterns through GraphQL Code Generator',
  author: 'arda',
  tags: ['graphql'],
  date: '2022-08-01',
  description: 'TBA',
  image:
    '/blog-assets/getting-the-best-out-of-your-graphql-client-by-using-relay-patterns-through-graphql-code-generator/cover.jpg'
}

export default withArticle(meta)

# Getting the best out of your GraphQL client by using Relay patterns through GraphQL Code Generator

There is no doubt that Relay is the most advanced JavaScript GraphQL Client that is out there. However, at the same time, the learning curve and adoption is yet very sparse compared to other popular alternatives such as Apollo Client, Urql, or GraphQL Request.

As a consequence, many people donâ€™t even know about all the benefits and patterns used within (and so far being exclusive to ) the relay-compiler, the GraphQL Code Generator counter-part tailored for Relay applications.

The Guild gathered and worked on projects whose GraphQL client usage spans across all the available solutions today. In our opinion, the most important parts of Relay are the concepts of building and scaling applications. These patterns are actually applicable to any GraphQL Client, you just need the right code generation tool for the job.

Fortunately, we are happy to announce that we now have an opinionated preset for bringing the Relay patterns to your existing project without having to switch over to the Relay eco-system.

## Describe component data needs via GraphQL fragments

Instead of writing one big GraphQL Operation for our whole page and passing that down to the components, start with describing the component's data dependencies through a GraphQL fragment.

```tsx
import { gql, useFragment, FragmentType } from '@gql'

const Avatar_UserFragment = gql(/* GraphQL */ `
  fragment Avatar_UserFragment on User {
    avatarUrl
  }
`)

type AvatarProps = {
  user: FragmentType<typeof Avatar_UserFragment>
}

export function Avatar(props: AvatarProps) {
  const user = useFragment(Avatar_UserFragment, props.user)
  return <CircleImage src={user.avatarUrl} />
}
```

## Compose fragments for UI components

As we compose simple visual UI components into bigger functional UI components we can also compose the fragments of the consumed UI component.

```tsx
import { gql, useFragment, FragmentType } from '@gql'
import { Avatar } from './avatar'

const UserListItem_UserFragment = gql(/* GraphQL */ `
  fragment UserListItem_UserFragment on User {
    fullName
    ...Avatar_UserFragment
  }
`)

type UserListItemProps = {
  user: FragmentType<typeof UserListItem_UserFragment>
}

export function UserListItem(props: UserListItemProps) {
  const user = useFragment(Item_UserFragment, props.user)
  return <ListItem icon={<Avatar user={user} />}>{user.fullName}</ListItem>
}
```

## Restrict which data can be accessed through fragments

By utilizing the `useFragment` hook we ensure that the component can only access the properties of the data that are declared directly within the fragment selection set. The other data declared through the additional fragment spread(`Avatar_UserFragment`), cannot be accessed within the `UserListItem` .

The following example would raise a TypeScript error, as the `avatarUrl` field is not selected within the `UserListItem_UserFragment` fragment.

```tsx
import { gql, useFragment, FragmentType } from '@gql'
import { Avatar } from './avatar'

const UserListItem_UserFragment = gql(/* GraphQL */ `
  fragment UserListItem_UserFragment on User {
    fullName
    ...Avatar_UserFragment
  }
`)

type UserListItemProps = {
  user: FragmentType<typeof UserListItem_UserFragment>
}

export function UserListItem(props: UserListItemProps) {
  const user = useFragment(Item_UserFragment, props.user)

  // ERROR: Property 'avatarUrl' does not exist on type
  const icon = <img src={user.avatarUrl} />
  return <ListItem icon={icon}>{user.fullName}</ListItem>
}
```

## Compose fragment components for your top-level route or view

We can now further compose our components till we reach those components that select the root Query object type.

```tsx
import { gql, useFragment, FragmentType } from '@gql'
import { UserListItem } from './user-list-item'

const FriendList_QueryFragment = gql(/* GraphQL */ `
  fragment FriendList_QueryFragment on Query {
    friends(first: 5) {
      id
      ...UserListItem_UserFragment
    }
  }
`)

type FriendListProps = {
  query: FragmentType<typeof FriendList_QueryFragment>
}

export function FriendList(props: FriendListProps) {
  const query = useFragment(FriendList_QueryFragment, props.query)
  return (
    <List>
      {query.friends.map((user) => (
        <FriendListItem key={user.id} user={user} />
      ))}
    </List>
  )
}
```

Earlier, we declared the `Avatar` component with the `Avatar_UserFragment` fragment. We can now re-use this Avatar in a different context by again spreading the fragment and then passing the relevant data to the `Avatar` component `user` property.

```tsx
import { gql, useFragment, FragmentType } from '@gql'

const UserProfileHeader_QueryFragment = gql(/* GraphQL */ `
  fragment UserProfileHeader_QueryFragment on Query {
    viewer {
      id
      homeTown
      registeredAt
      ...Avatar_UserFragment
    }
  }
`)

type UserProfileHeaderProps = {
  query: FragmentType<typeof UserProfileHeader_QueryFragment>
}

export function UserProfileHeader(props: UserProfileHeaderProps) {
  const query = useFragment(UserProfileHeader_QueryFragment, props.query)
  return (
    <>
      <Avatar user={query.viewer} />
      {query.viewer.homeTown}
      {query.viewer.registeredAt}
    </>
  )
}
```

Now, we have two UI components that require data from the root Query type, `FriendList` and `UserProfileHeader` .

## Compose all Query fragments into a single Query operation

Finally, we can spread all our fragments into a single GraphQL Query operation that fetches all the data on our route component. This allows us to efficiently fetch all the data required for the route in one server roundtrip.

```jsx
import { gql, useFragment, FragmentType } from '@gql'
import { UserProfileHeader } from './user-profile-header'
import { FriendList } from './friend-list'

const UserProfileRoute_Query = gql(/* GraphQL */ `
  query UserProfile_Query {
    ...UserProfileHeader_QueryFragment
    ...UserList_QueryFragment
  }
`)

export function UserProfileRoute_Query() {
  const { data, loading, error } = useQuery(UserProfile_Query)
  if (loading) return <Loading />
  if (error) return <Error />
  return (
    <>
      <FriendList query={data} />
      <UserProfileHeader query={data} />
    </>
  )
}
```

## Conclusion

This pattern allows you to re-use and scale your components to the maximum while having a clear and sane data dependency flow from the top route down to the ends of the UI component trees.

You can start adopting this pattern within your GraphQL application with any GraphQL client that supports `TypedDocumentNode` through our new and battle-tested GraphQL Code Generator preset `[gql-tag-operations-preset](https://www.graphql-code-generator.com/plugins/presets/gql-tag-operations-preset)`.

[You can start quickly without much configuration by following the preset documentation.](https://www.graphql-code-generator.com/plugins/presets/gql-tag-operations-preset)

What are you waiting for? Nobody is stopping you from incrementally bringing sanity to your GraphQL application!

Maybe this even inspires you to dig deeper into the optimizations the Relay client runtime does on top of these patterns and convince you to use Relay within your next project. You can learn more about those on [relay.dev](https://relay.dev/).

We, as The Guild, want you to find the right tool for your expertise and the application you are building. The most important thing is the patterns that are applicable anywhere!
