import withArticle from '../../ui/blog/article';

export const meta = {
  title: 'The Stack #1',
  author: 'tvvignesh',
  tags: ['graphql', 'deepdive', 'techstack'],
  date: '2020-12-03',
  description: 'The GraphQL Stack - Part 1',
  image: '/blog-assets/graphql-deep-dive-3/cover.png',
  thumbnail: '/blog-assets/graphql-deep-dive-3/cover.png',
};

export default withArticle({ ...meta });

_This blog is a part of a series on GraphQL where we will dive deep into GraphQL and its ecosystem one piece at a time_

- Part 1: [**Diving Deep**](/blog/graphql-deep-dive-1)
- Part 2: [**The Usecase & Architecture**](/blog/graphql-deep-dive-2)
- Part 3: [**The Stack #1**](/blog/graphql-deep-dive-3)
- Part 4: [**The Stack #2**](/blog/graphql-deep-dive-4)
- Part 5: [**The Stack #3**](/blog/graphql-deep-dive-5)
- Part 6: [**The Workflow**](/blog/graphql-deep-dive-6)

Now that we have discussed about GraphQL, and also about some of the architectural considerations when starting off, let’s look at the next important step in the puzzle — choosing the right tech stack for your usecase and building the development workflow which suits you best in this blog.

Technology changes and evolves constantly as we have already seen it happening all these days. So, rather than worrying too much about the technology you choose, it is better to choose a tool, library or platform which allows for incremental changes without lockin. Using the list in the [**previous blog post**](/blog/graphql-deep-dive-2) might actually help in your decision making process.

But, today I am going to assume a tech stack (the GraphQL Tech Stack that I work with everyday to build [Timecampus](https://www.twitter.com/timecampus)) and walk you through. The reason I say **“GraphQL” Tech Stack** is because, this is just a part of the complete stack I use and there is more to it which we will discuss sometime down the line in a different blog.

**NOTE:** While these work great for me, this is an area of continuous exploration for me and I don’t mind replacing X with Y as long as the effort is really worth it from a future perspective (we will explore more on what they are and why we use these as we go along). With that, let’s start.

[**VSCode**](https://code.visualstudio.com/)

There is no doubt that VSCode has become the defacto editor which developers user these days. And it definitely deserves the recognition and credit it gets. VSCode comes with amazing extensions and tooling for GraphQL and its ecosystem built by the community and if you work with GraphQL and Typescript, I would say it is pretty much a standard editor which you would definitely want to use.

For instance, just do a search for “GraphQL” in the marketplace, and this is what you get:

![Image for post](/blog-assets/graphql-deep-dive-3/1.png)

and the ecosystem is growing even more everyday and this makes VSCode indispensable for our stack.

[**GraphQL Config**](https://graphql-config.com/)

GraphQL Config acts as a single configuration point for all that we do with GraphQL. This is important because when working on projects, it is important to have little to no repetition (DRY principle) and having a separate config file for every tool will start getting overwhelming and messy over time since we will have multiple places to maintain.

We can specify all that we want regarding GraphQL in a single `.graphqlrc` file as mentioned in the docs starting from the location to the schema, the GraphQL documents (queries and mutations), and also the configuration for extensions which we use with it.

Not just this, a single `.graphqlrc` file can be used to specify all the configuration you need for multiple projects that you use in your workspace.

For eg. it can integrate with our VSCode GraphQL extension to provide autocompletion, intellisense and so on, provide all the config needed to do code generation with GraphQL codegen, linting with GraphQL ESLint and can also pave way to all the other tools we may integrate in the future.

A `.graphqlrc.yml` file may look something like this:

![Image for post](/blog-assets/graphql-deep-dive-3/2.png)

GraphQL Config Snippet

[**VSCode GraphQL**](https://github.com/graphql/vscode-graphql)

The next thing which comes to mind is a VSCode extension which can provide the support for all the things you need to do with GraphQL. Originally developed by the amazing people at [**Prisma**](https://www.prisma.io/) this extension was later donated to the [**GraphQL Foundation**](https://foundation.graphql.org/) and the reason this extension is really promising is because, it provides everything you need to work with GraphQL including syntax highlighting, autocompletion, validation, SDL navigation, execute, operations, support for tagged template literals and all of this with support for GraphQL Config and it works great.

**NOTE:** If you are using the Apollo Stack (like Federation), I would recommend you to go with [**Apollo VSCode**](https://www.apollographql.com/docs/devtools/editor-plugins/) instead since it provides support for things like `apollo.config.js` (which integrates with the schema registry), federation directives and so on.

[**GraphQL ESLint**](https://github.com/dotansimha/graphql-eslint)

The next thing which is important when you work with GraphQL as a team is following a set of standards so that everyone is on the same page. This is where using a linter like GraphQL ESLint would really help. The beauty is that it integrates seamlessly with GraphQL Config, supports ESLint natively and also provides some [**inbuilt rules**](https://github.com/dotansimha/graphql-eslint/blob/master/docs/README.md) which is a great start to work with like consistent case, making naming of operations mandatory, forcing a deprecation reason and so on which can be of great use as you scale up with GraphQL.

A sample `.eslintrc` file to be used for GraphQL ESLint would look something like this:

![Image for post](/blog-assets/graphql-deep-dive-3/3.png)

GraphQL ESLint snippet

[**GraphQL Inspector**](https://graphql-inspector.com/)

How do you make collaborating with GraphQL very easy? And how do you do this in such a way that you have all the information you need to take a specific action? What if there are breaking changes to your schema? Errors and issues may creep in anywhere and at anytime.

This is where GraphQL inspector comes in. It provides a platform with various functionalities like schema validation, coverage, finding similar operations, inspecting the difference between different versions of the schema, mock your schema with test data and also a Github application to do all this for you when you raise a pull request.

For eg. this is how finding the coverage of your operations against the schema looks like:

![Image for post](/blog-assets/graphql-deep-dive-3/4.png)

GraphQL Coverage

And if you want to find similar fields/types within your schema, this is how it will look like:

![Image for post](/blog-assets/graphql-deep-dive-3/5.png)

GraphQL Similarity

[**Typescript**](https://www.typescriptlang.org/)

When I initially started off with Typescript few years ago, I was not sure of the advantages it would provide me over time for the effort I am putting in to make the code I write completely typed. To be honest, it takes a lot of effort and sometimes can be painful. But, this perception changed over time especially when I started working with GraphQL and Typescript.

The reason GraphQL works great with Typescript is mainly because of a lot of similarities between them with both being strongly typed, providing a clear path to documentation, offering great validations and also a great ecosystem built both on top of Typescript and GraphQL.

This will become more evident as we go through this blog. But, writing the types manually for each and every field in the schema or for every operation and keeping them updated can be a huge task. This is where a lot of amazing tools come in like GraphQL Codegen, Typed Document Node, Typegraphql and so on.

And on top of this, the beauty is that, with GraphQL and Typescript, we can actually make the end-end stack fully typed (which is what we do at [Timecampus](https://www.twitter.com/timecampus)). And after seeing all this happening, even `graphql-js` is on its [path to migration with Typescript](https://github.com/graphql/graphql-js/issues/2104).

[**Graphql Helix**](https://github.com/contrawork/graphql-helix)

There are a lot of GraphQL servers out there. And we even spoke about some of those in our [**first blog post**](/blog/graphql-deep-dive-1). While it is not necessary to pick an out of the box GraphQL server since you can build your own using `graphql-js` , it may not be a smart choice since you might not want to reinvent the wheel.

This is where I use GraphQL Helix which provides me a GraphQL server and also the option to selectively replace any module that I need to work for your usecase. This is very evident from the [**examples folder**](https://github.com/contrawork/graphql-helix/tree/master/examples) of the repository demonstrating various usecases like subscriptions, csp, graphql-modules, persisted-queries and so on and also with various frameworks like express, fastify, koa.

And since there are no outside dependencies except for `graphql-js` there is also no bloat to the same unlike other graphql servers. If you want to see how other GraphQL servers perform, you might want to have a look at [this](https://github.com/benawad/node-graphql-benchmarks).

[**GraphQL Codegen**](https://graphql-code-generator.com/)

We did discuss how Typescript and GraphQL works seamlessly well with each other. But what if we can generate all that we can from our SDL which provides majority of the information that one needs including name of the schema, fields, types, and so on.

And this is where GraphQL Codegen plays a major role. You can generate all the types, interfaces and so on and it also comes with a lot of [**plugins**](https://graphql-code-generator.com/docs/plugins/index) and [**presets**](https://graphql-code-generator.com/docs/presets/presets-index) to help you work with not just Typescript, but also other languages and tooling. All we have to do is import the type we need and just use it making it really simple. And every time we change the schema, we can just regenerate the types. Also, it integrates seamlessly with GraphQL Config making it really easy to maintain.

For eg. this is how the generated types look like:

![Image for post](/blog-assets/graphql-deep-dive-3/6.png)

There are more tools, libraries and platforms we have to talk about as part of our GraphQL Stack and we will be continuing our discussion in the next blog post. Hope this was insightful.

If you have any questions or are looking for help, feel free to reach out to me [@techahoy](https://twitter.com/techahoy) anytime.

And if this helped, do share this across with your friends, do hang around and follow us for more like this every week. See you all soon.
